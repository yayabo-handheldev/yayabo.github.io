
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>lua 中的 Metatables and Metamethods</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    </head>

    <body style="margin-top:1.618%">
        <div class="container">
            <div class="row">
                <div class="jumbotron">
                    <h1 class="display-5">lua 中的 Metatables and Metamethods</h1>
                </div>
                <br />
                <nav class="nav">
                    <a class="nav-link active" aria-current="page" href="index_2.html">返回</a>
                </nav>
            </div>

            <hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2010-01-18 20:43:54</p>
</div>
<div class="col-10">
<p>Lua中的table由于定义的行为，我们可以对key-value对执行加操作，访问key对应的value，遍历所有的key-value。但是我们不可以对两个table执行加操作，也不可以比较两个表的大小。<br />Metatables 允许我们改变table的行为，例如，使用Metatables我们可以定义Lua如何计算两个table的相加操作a+b。当Lua试图对两个表进行相加时，他会检查两个表是否有一个表有Metatable，并且检查Metatable是否有__add域。如果找到则调用这个__add函数（所谓的 Metamethod）去计算结果。<br />Lua中的每一个表都有其Metatable。（后面我们将看到userdata也有Metatable），Lua默认创建一个不带metatable的新表<br />t = {}<br />print(getmetatable(t))      --> nil<br />可以使用setmetatable函数设置或者改变一个表的metatable<br />t1 = {}<br />setmetatable(t, t1)<br />assert(getmetatable(t) == t1)<br />任何一个表都可以是其他一个表的metatable，一组相关的表可以共享一个metatable（描述他们共同的行为）。一个表也可以是自身的metatable（描述其私有行为）。<br />13.1 算术运算的Metamethods<br />这一部分我们通过一个简单的例子介绍如何使用metamethods。假定我们使用table来描述结合，使用函数来描述集合的并操作，交集操作，like操作。我们在一个表内定义这些函数，然后使用构造函数创建一个集合：<br />Set = {}<br /><br />function Set.new (t)<br />    local set = {}<br />    for _, l in ipairs(t) do set[l] = true end<br />    return set<br />end<br /><br />function Set.union (a,b)<br />    local res = Set.new{}<br />    for k in pairs(a) do res[k] = true end<br />    for k in pairs(b) do res[k] = true end<br />    return res<br />end<br /><br />function Set.intersection (a,b)<br />    local res = Set.new{}<br />    for k in pairs(a) do<br />      res[k] = b[k]<br />    end<br />    return res<br />end<br />为了帮助理解程序运行结果，我们也定义了打印函数输出结果：<br />function Set.tostring (set)<br />    local s = "{"<br />    local sep = ""<br />    for e in pairs(set) do<br />      s = s .. sep .. e<br />      sep = ", "<br />    end<br />    return s .. "}"<br />end<br /><br />function Set.print (s)<br />    print(Set.tostring(s))<br />end<br />现在我们想加号运算符(+)执行两个集合的并操作，我们将所有集合共享一个metatable，并且为这个metatable添加如何处理相加操作。<br />第一步，我们定义一个普通的表，用来作为metatable。为避免污染命名空间，我们将其放在set内部。<br />Set.mt = {}      -- metatable for sets<br />第二步，修改set.new函数，增加一行，创建表的时候同时指定对应的metatable。<br />function Set.new (t)    -- 2nd version<br />    local set = {}<br />    setmetatable(set, Set.mt)<br />    for _, l in ipairs(t) do set[l] = true end<br />    return set<br />end<br />这样一来，set.new创建的所有的集合都有相同的metatable了：<br />s1 = Set.new{10, 20, 30, 50}<br />s2 = Set.new{30, 1}<br />print(getmetatable(s1))    --> table: 00672B60<br />print(getmetatable(s2))    --> table: 00672B60<br />第三步，给metatable增加__add函数。<br />Set.mt.__add = Set.union<br />当Lua试图对两个集合相加时，将调用这个函数，以两个相加的表作为参数。<br />通过metamethod，我们可以对两个集合进行相加：<br />s3 = s1 + s2<br />Set.print(s3)    --> {1, 10, 20, 30, 50}<br />同样的我们可以使用相乘运算符来定义集合的交集操作<br />Set.mt.__mul = Set.intersection<br /><br />Set.print((s1 + s2)*s1)    --> {10, 20, 30, 50}<br />对于每一个算术运算符，metatable都有对应的域名与其对应，除了__add、__mul外，还有__sub(减)、__div(除)、__unm(负)、__pow(幂)，我们也可以定义__concat定义连接行为。<br />当我们对两个表进行加没有问题，但如果两个操作数有不同的metatable例如：<br />s = Set.new{1,2,3}<br />s = s + 8<br />Lua选择metamethod的原则：如果第一个参数存在带有__add域的metatable，Lua使用它作为metamethod，和第二个参数无关；<br />否则第二个参数存在带有__add域的metatable，Lua使用它作为metamethod 否则报错。<br />Lua不关心这种混合类型的，如果我们运行上面的s=s+8的例子在Set.union发生错误：<br />bad argument #1 to `pairs' (table expected, got number)<br />如果我们想得到更加清楚地错误信息，我们需要自己显式的检查操作数的类型：<br />function Set.union (a,b)<br />    if getmetatable(a) ~= Set.mt or<br />                    getmetatable(b) ~= Set.mt then<br />      error("attempt to `add' a set with a non-set value", 2)<br />    end<br />      ... -- same as before<br />13.2 关系运算的Metamethods<br />Metatables 也允许我们使用metamethods：__eq（等于），__lt（小于），和__le（小于等于）给关系运算符赋予特殊的含义。对剩下的三个关系运算符没有专门的metamethod，因为Lua将a ~= b转换为not (a == b)；a > b转换为b < a；a >= b转换为 b <= a。<br />（直到Lua 4.0为止，所有的比较运算符被转换成一个，a <= b转为not (b < a)。然而这种转换并不一致正确。当我们遇到偏序（partial order）情况，也就是说，并不是所有的元素都可以正确的被排序情况。例如，在大多数机器上浮点数不能被排序，因为他的值不是一个数字（Not a Number即NaN）。根据IEEE 754的标准，NaN表示一个未定义的值，比如0/0的结果。该标准指出任何涉及到NaN比较的结果都应为false。也就是说，NaN <= x总是false，x < NaN也总是false。这样一来，在这种情况下a <= b 转换为 not (b < a)就不再正确了。）<br />在我们关于基和操作的例子中，有类似的问题存在。<=代表集合的包含：a <= b表示集合a是集合b的子集。这种意义下，可能a <= b和b < a都是false；因此，我们需要将__le和__lt的实现分开：<br />Set.mt.__le = function (a,b)    -- set containment<br />    for k in pairs(a) do<br />      if not b[k] then return false end<br />    end<br />    return true<br />end<br /><br />Set.mt.__lt = function (a,b)<br />    return a <= b and not (b <= a)<br />end<br />最后，我们通过集合的包含来定义集合相等：<br />Set.mt.__eq = function (a,b)<br />    return a <= b and b <= a<br />end<br />有了上面的定义之后，现在我们就可以来比较集合了：<br />s1 = Set.new{2, 4}<br />s2 = Set.new{4, 10, 2}<br />print(s1 <= s2)          --> true<br />print(s1 < s2)          --> true<br />print(s1 >= s1)          --> true<br />print(s1 > s1)          --> false<br />print(s1 == s2 * s1)    --> true<br />与算术运算的metamethods不同，关系元算的metamethods不支持混合类型运算。对于混合类型比较运算的处理方法和Lua的公共行为类似。如果你试图比较一个字符串和一个数字，Lua将抛出错误。相似的，如果你试图比较两个带有不同metamethods的对象，Lua也将抛出错误。<br />但相等比较从来不会抛出错误，如果两个对象有不同的metamethod，比较的结果为false，甚至可能不会调用metamethod。这也是模仿了 Lua的公共的行为，因为Lua总是认为字符串和数字是不等的，而不去判断它们的值。仅当两个有共同的metamethod的对象进行相等比较的时候，Lua才会调用对应的metamethod。<br />13.3 库定义的Metamethods<br />在一些库中，在自己的metatables中定义自己的域是很普遍的情况。到目前为止，我们看到的所有metamethods都是Lua核心部分的。有虚拟机负责处理运算符涉及到的 metatables和为运算符定义操作的metamethods。但是，metatable是一个普通的表，任何人都可以使用。<br />tostring是一个典型的例子。如前面我们所见，tostring以简单的格式表示出table：<br />print({})    --> table: 0x8062ac0<br />（注意：print函数总是调用tostring来格式化它的输出）。然而当格式化一个对象的时候，tostring会首先检查对象是否存在一个带有 __tostring域的metatable。如果存在则以对象作为参数调用对应的函数来完成格式化，返回的结果即为tostring的结果。<br />在我们集合的例子中我们已经定义了一个函数来将集合转换成字符串打印出来。因此，我们只需要将集合的metatable的__tostring域调用我们定义的打印函数：<br />Set.mt.__tostring = Set.tostring<br />这样，不管什么时候我们调用print打印一个集合，print都会自动调用tostring，而tostring则会调用Set.tostring：<br />s1 = Set.new{10, 4, 5}<br />print(s1)    --> {4, 5, 10}<br />setmetatable/getmetatable 函数也会使用metafield，在这种情况下，可以保护metatables。假定你想保护你的集合使其使用者既看不到也不能修改 metatables。如果你对metatable设置了__metatable的值，getmetatable将返回这个域的值，而调用 setmetatable 将会出错：<br />Set.mt.__metatable = "not your business"<br /><br />s1 = Set.new{}<br />print(getmetatable(s1))    --> not your business<br />setmetatable(s1, {})<br />stdin:1: cannot change protected metatable<br />13.4 表相关的Metamethods<br />关于算术运算和关系元运算的metamethods都定义了错误状态的行为，他们并不改变语言本身的行为。针对在两种正常状态：表的不存在的域的查询和修改，Lua也提供了改变tables的行为的方法。<br />13.4.1 The __index Metamethod<br />前面说过，当我们访问一个表的不存在的域，返回结果为nil，这是正确的，但并不一定正确。实际上，这种访问触发lua解释器去查找__index metamethod：如果不存在，返回结果为nil；如果存在则由__index metamethod返回结果。<br />这个例子的原型是一种继承。假设我们想创建一些表来描述窗口。每一个表必须描述窗口的一些参数，比如：位置，大小，颜色风格等等。所有的这些参数都有默认的值，当我们想要创建窗口的时候只需要给出非默认值的参数即可创建我们需要的窗口。第一种方法是，实现一个表的构造器，对这个表内的每一个缺少域都填上默认值。第二种方法是，创建一个新的窗口去继承一个原型窗口的缺少域。首先，我们实现一个原型和一个构造函数，他们共享一个metatable：<br />-- create a namespace<br />Window = {}<br />-- create the prototype with default values<br />Window.prototype = {x=0, y=0, width=100, height=100, }<br />-- create a metatable<br />Window.mt = {}<br />-- declare the constructor function<br />function Window.new (o)<br />    setmetatable(o, Window.mt)<br />    return o<br />end<br />现在我们定义__index metamethod：<br />Window.mt.__index = function (table, key)<br />    return Window.prototype[key]<br />end<br />这样一来，我们创建一个新的窗口，然后访问他缺少的域结果如下：<br />w = Window.new{x=10, y=20}<br />print(w.width)      --> 100<br />当 Lua发现w不存在域width时，但是有一个metatable带有__index域，Lua使用w（the table）和width（缺少的值）来调用__index metamethod，metamethod则通过访问原型表（prototype）获取缺少的域的结果。<br />__index metamethod在继承中的使用非常常见，所以Lua提供了一个更简洁的使用方式。__index metamethod不需要非是一个函数，他也可以是一个表。但它是一个函数的时候，Lua将table和缺少的域作为参数调用这个函数；当他是一个表的时候，Lua将在这个表中看是否有缺少的域。所以，上面的那个例子可以使用第二种方式简单的改写为：<br />Window.mt.__index = Window.prototype<br />现在，当Lua查找metatable的__index域时，他发现window.prototype的值，它是一个表，所以Lua将访问这个表来获取缺少的值，也就是说它相当于执行：<br />Window.prototype["width"]<br />将一个表作为__index metamethod使用，提供了一种廉价而简单的实现单继承的方法。一个函数的代价虽然稍微高点，但提供了更多的灵活性：我们可以实现多继承，隐藏，和其他一些变异的机制。我们将在第16章详细的讨论继承的方式。<br />当我们想不通过调用__index metamethod来访问一个表，我们可以使用rawget函数。Rawget(t,i)的调用以raw access方式访问表。这种访问方式不会使你的代码变快（the overhead of a function call kills any gain you could have），但有些时候我们需要他，在后面我们将会看到。<br />13.4.2 The __newindex Metamethod<br />__newindex metamethod用来对表更新，__index则用来对表访问。当你给表的一个缺少的域赋值，解释器就会查找__newindex metamethod：如果存在则调用这个函数而不进行赋值操作。像__index一样，如果metamethod是一个表，解释器对指定的那个表，而不是原始的表进行赋值操作。另外，有一个raw函数可以绕过metamethod：调用rawset(t,k,v)不掉用任何metamethod对表t的 k域赋值为v。__index和__newindex metamethods的混合使用提供了强大的结构：从只读表到面向对象编程的带有继承默认值的表。在这一张的剩余部分我们看一些这些应用的例子，面向对象的编程在另外的章节介绍。<br />13.4.3有默认值的表<br />在一个普通的表中任何域的默认值都是nil。很容易通过metatables来改变默认值：<br />function setDefault (t, d)<br />    local mt = {__index = function () return d end}<br />    setmetatable(t, mt)<br />end<br /><br />tab = {x=10, y=20}<br />print(tab.x, tab.z)      --> 10  nil<br />setDefault(tab, 0)<br />print(tab.x, tab.z)      --> 10  0<br />现在，不管什么时候我们访问表的缺少的域，他的__index metamethod被调用并返回0。setDefault函数为每一个需要默认值的表创建了一个新的metatable。在有很多的表需要默认值的情况下，这可能使得花费的代价变大。然而metatable有一个默认值d和它本身关联，所以函数不能为所有表使用单一的一个metatable。为了避免带有不同默认值的所有的表使用单一的metatable，我们将每个表的默认值，使用一个唯一的域存储在表本身里面。如果我们不担心命名的混乱，我可使用像"___"作为我们的唯一的域：<br />local mt = {__index = function (t) return t.___ end}<br />function setDefault (t, d)<br />    t.___ = d<br />    setmetatable(t, mt)<br />end<br />如果我们担心命名混乱，也很容易保证这个特殊的键值唯一性。我们要做的只是创建一个新表用作键值：<br />local key = {}    -- unique key<br />local mt = {__index = function (t) return t[key] end}<br />function setDefault (t, d)<br />    t[key] = d<br />    setmetatable(t, mt)<br />end<br />另外一种解决表和默认值关联的方法是使用一个分开的表来处理，在这个特殊的表中索引是表，对应的值为默认值。然而这种方法的正确实现我们需要一种特殊的表：weak table，到目前为止我们还没有介绍这部分内容，将在第17章讨论。<br />为了带有不同默认值的表可以重用相同的原表，还有一种解决方法是使用memoize metatables，然而这种方法也需要weak tables，所以我们再次不得不等到第17章。<br />13.4.4监控表<br />__index 和__newindex都是只有当表中访问的域不存在时候才起作用。捕获对一个表的所有访问情况的唯一方法就是保持表为空。因此，如果我们想监控一个表的所有访问情况，我们应该为真实的表创建一个代理。这个代理是一个空表，并且带有__index和__newindex metamethods，由这两个方法负责跟踪表的所有访问情况并将其指向原始的表。假定，t是我们想要跟踪的原始表，我们可以：<br />t = {}    -- original table (created somewhere)<br /><br />-- keep a private access to original table<br />local _t = t<br /><br />-- create proxy<br />t = {}<br /><br />-- create metatable<br />local mt = {<br />    __index = function (t,k)<br />    print("*access to element " .. tostring(k))<br />    return _t[k] -- access the original table<br />    end,<br /><br />    __newindex = function (t,k,v)<br />    print("*update of element " .. tostring(k) ..<br />              " to " .. tostring(v))<br />    _t[k] = v    -- update original table<br />    end<br />}<br />setmetatable(t, mt)<br />这段代码将跟踪所有对t的访问情况：<br />> t[2] = 'hello'<br />*update of element 2 to hello<br />> print(t[2])<br />*access to element 2<br />hello<br />（注意：不幸的是，这个设计不允许我们遍历表。Pairs函数将对proxy进行操作，而不是原始的表。）如果我们想监控多张表，我们不需要为每一张表都建立一个不同的metatable。我们只要将每一个proxy和他原始的表关联，所有的proxy共享一个公用的metatable即可。将表和对应的 proxy关联的一个简单的方法是将原始的表作为proxy的域，只要我们保证这个域不用作其他用途。一个简单的保证它不被作他用的方法是创建一个私有的没有他人可以访问的key。将上面的思想汇总，最终的结果如下：<br />-- create private index<br />local index = {}<br /><br />-- create metatable<br />local mt = {<br />    __index = function (t,k)<br />      print("*access to element " .. tostring(k))<br />      return t[index][k]  -- access the original table<br />    end<br /><br />    __newindex = function (t,k,v)<br />    print("*update of element " .. tostring(k) .. " to "<br />                  .. tostring(v))<br />    t[index][k] = v          -- update original table<br />    end<br />}<br /><br />function track (t)<br />    local proxy = {}<br />    proxy[index] = t<br />    setmetatable(proxy, mt)<br />    return proxy<br />end<br />现在，不管什么时候我们想监控表t，我们要做得只是t=track(t)。<br />13.4.5只读表<br />采用代理的思想很容易实现一个只读表。我们需要做得只是当我们监控到企图修改表时候抛出错误。通过__index metamethod，我们可以不使用函数而是用原始表本身来使用表，因为我们不需要监控查寻。这是比较简单并且高效的重定向所有查询到原始表的方法。但是，这种用法要求每一个只读代理有一个单独的新的metatable，使用__index指向原始表：<br />function readOnly (t)<br />    local proxy = {}<br />    local mt = {        -- create metatable<br />      __index = t,<br />      __newindex = function (t,k,v)<br />          error("attempt to update a read-only table", 2)<br />      end<br />    }<br /><br />    setmetatable(proxy, mt)<br />    return proxy<br />end<br />（记住：error的第二个参数2，将错误信息返回给企图执行update的地方）作为一个简单的例子，我们对工作日建立一个只读表：<br />days = readOnly{"Sunday", "Monday", "Tuesday", "Wednesday",<br />      "Thursday", "Friday", "Saturday"}<br /><br />print(days[1])      --> Sunday<br />days[2] = "Noday"<br />stdin:1: attempt to update a read-only table</p>
</div>
</div>


            
            <div class="row">
                <nav aria-label="Page navigation example">
                    <ul class="pagination justify-content-center">
                    <!--<li class="page-item disabled">
                        <a class="page-link">Previous</a>
                    </li>
                    <li class="page-item"><a class="page-link" href="#">1</a></li>
                    <li class="page-item"><a class="page-link" href="#">2</a></li>
                    <li class="page-item"><a class="page-link" href="#">3</a></li>
                    <li class="page-item">
                        <a class="page-link" href="#">Next</a>
                    </li>
                        -->
                        <li class="page-item active">
<a class="page-link" href="post1111_1.html">1</a>
</li>


                    </ul>
                </nav>
            </div>
        </div>


        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    </body>
</html>

