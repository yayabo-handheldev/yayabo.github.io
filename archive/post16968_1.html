
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>NDS自制软件教程7</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    </head>

    <body style="margin-top:1.618%">
        <div class="container">
            <div class="row">
                <div class="jumbotron">
                    <h1 class="display-5">NDS自制软件教程7</h1>
                </div>
                <br />
                <nav class="nav">
                    <a class="nav-link active" aria-current="page" href="index_17.html">返回</a>
                </nav>
            </div>

            <hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-15 09:37:51</p>
</div>
<div class="col-10">
<p>摘自：ndsbbs<br />作者：nashi1987<br /><br />FIFO：<br /><br />在教程6中我们讲解了一种处理器间通信的方法，虽然能很好的工作但有两个问题。第一是他需要将数据存储到一个共享内存中，ARM7不断检测这部分内存以判断是否有新信息写入。第二是这样没有办法让ARM7返回数据给 ARM9。有一种新方法可以解决这些问题。DS有一个内置的FIFO队列。FIFO是基于‘先入先出’。这种数据结构允许一个‘发送者’将将数据一个一个的顺序存入队列，一个‘接受者’可以从队列中得到数据，从发送者先存入的开始。FIFO由此得名。FIFO也有一个中断，它在有数据传入或移出队列时发生。这样就比不断检测更有效。所以我们可以让ARM9在将指令写入队列时ARM7可以立即知道在队列中有新项目并立即执行。<br /><br />本教程借鉴了DSLINUX和DSTEK的相关资料。<br /><br />FIFO寄存器：<br /><br />与FIFO有关的寄存器有3个，他们是：<br /><br /><br />  Define           Address     Size       Description<br />REG_IPCFIFOCNT 0x04000184   16 bits Used for getting the status of  <br />                                          the FIFO, reseting it, setting  <br />                                          interrupts, etc.<br /><br />REG_IPCFIFOSEND 0x04000188 32 bits Write only register for sending  <br />                                          data to the FIFO.<br />REG_IPCFIFORECV 0x04100000 32 bits Read only register for retrieving<br />                                          data from the FIFO.<br /><br /><br /><br />REG_IPCFIFOCNT：<br /><br />控制寄存器有16位，我所知道的是：<br /><br /><br />      Define           Bit   Read/Write   Description<br />IPC_FIFO_SEND_EMPTY   0     R         Clear if nothing has been sent,<br />                                            otherwise set.<br />IPC_FIFO_SEND_FULL   1       R         Set if the send queue is full.<br />IPC_FIFO_SEND_IRQ     2     R/W       If set an interrupt will occur  <br />                                            when something is put on the  <br />                                            queue.<br />IPC_FIFO_SEND_CLEAR   3     W         Empties the send queue when set.<br />IPC_FIFO_RECV_EMPTY   8       R         Clear if nothing is in the    <br />                                          receive queue, otherwise set.<br />IPC_FIFO_RECV_FULL     9     R         Set if the receive queue is full.<br />IPC_FIFO_RECV_IRQ     10     R/W       If set an interrupt will occur when<br />                                          something is received from the  <br />                                          queue.<br />IPC_FIFO_ERROR         14     R         Set if an error occurs during a<br />                                          send or receive.<br />IPC_FIFO_ENABLE       15     R/W       Enables the FIFO queue.<br />                                            REG_IPCFIFOSEND：<br /><br /><br />这是一个32位只写寄存器。当一个数据写入这个寄存器时它被放到处理器的传送队列中。这个队列只可以存储16项，所以另一个处理器应当及时的接受这些项目。当一个项目写入时，不同处理器的控制寄存器的一些位会改变。不同的CPU控制寄存器的值不同。下面的表格显示当一个‘传送CPU’向传送寄存器写入数据后对控制寄存器中一些位的影响：<br /><br /><br />Name                         Effect<br />      Sending CPU<br />IPC_FIFO_SEND_EMPTY     传送队列不为空时置位<br />IPC_FIFO_SEND_FULL       传送时如果传送队列已满则置位<br />IPC_FIFO_ERROR             如果传送队列已满则置位<br />      Receiving CPU<br />IPC_FIFO_RECV_EMPTY     接收队列不为空时置位<br />IPC_FIFO_RECV_FULL       传送时如果接收队列已满则置位<br /><br /><br />从以上数据你可以猜到传送CPU的传送队列是接收CPU的接收队列。<br /><br />REG_IPCFIFORECV：<br /><br />这是一个32位只读寄存器。当接收队列不为空时，你可以从中读取另一个寄存器存如的数据。<br />当一个项目从寄存器中读取后另一个CPU的控制寄存器的一些位会改变。下面的表格描述当接收CPU从这个寄存器中读取一个项目后对控制寄存器的影响：<br /><br /><br />    Name                         Effect<br />        Receiving CPU<br />IPC_FIFO_RECV_EMPTY       当读取的项目是接收队列的最后一项时清零<br />IPC_FIFO_RECV_FULL         接收执行前若队列已满则清零<br />IPC_FIFO_ERROR             当尝试从空队列中读取项目时置位<br />        Receiving CPU<br />IPC_FIFO_SEND_EMPTY       当传送队列为空时清零<br />IPC_FIFO_SEND_FULL         接收执行前若队列已满则清零<br /><br /><br /><br />FIFO用法：<br /><br />通过寄存器的解释我们应该对FIFO如何工作了解一些了。每一个CPU有一个可以存放数据的队列。数据写入通过将32为数据写入 ‘REG_IPCFIFOSEND’寄存器完成。另一个CPU可以通过从‘REG_IPCFIFORECV’寄存器中读取数据来接收这些数据。它将接收到原始CPU最先放入的数据。在控制寄存器‘REG_IPCFIFOCNT’中的一些位可用来判断队列中是否有需要读取的项目以及队列为空或已满。最多可以向队列中存储16个项目。所以同时ARM9和ARM7间可以相互传输16个项目。虽然使用相同的寄存器数量，但每一个CPU有独立的队列来实现双向通信。使用轮流检测来从队列中接收数据，最好先检测队列是否为空，若不为空则处理一个项目，或循环处理所有项目。例如：<br /><br /><br />// One item<br />if(!(REG_IPCFIFOCNT & IPC_FIFO_RECV_EMPTY))<br />  processItem(REG_IPCFIFORECV);<br /><br />// All items<br />while(!(REG_IPCFIFOCNT & IPC_FIFO_RECV_EMPTY))<br />  processItem(REG_IPCFIFORECV);  <br /><br /><br />如果传送CPU也在添加项目循环中则这个循环很可能不能终止。你也可以使用中断来判断接收队列中是否有新项目。这在以后的教程中会讲解。<br /><br /><br />示例程序：<br /><br />我们用来测试这些的示例程序叫做fifo_demo1。它使用简单的控制行输出来显示寄存器中的内容，当按键按下后ARM7与ARM9间相互传输数据，对寄存器产生的效果被显示出来。当使用者按下“上”时，相关CPU的FIFO寄存器启动。当“右”按下时，向传送寄存器写入一个项目。当“下”按下后从接收寄存器中读取一个项目储存到一个变量中并在垂直扫描中断时显示。所执行操作的CPU由左右肩的按键（R/L）控制。按住L键不放则操作按键的操作由ARM7 执行，按住R键不放则使用ARM9。<br /><br /><br />Shoulder Button Direction Button     Action<br />    Left               Up       Enable ARM7 FIFO<br />    Left               Right       Write on the ARM7's send queue<br />    Left               Down       Receive from the ARM7's receive queue<br />    Right             Up       Enable ARM9 FIFO<br />    Right             Right       Write on the ARM9's send queue<br />    Right             Down       Receive from the ARM9's receive queue<br /><br /><br /><br />一个简单的测试操作：<br /><br />1.初始化时屏幕显示：<br /><br /><br />ARM9 Fifo Registers:<br />REG_IPCFIFOCNT:     101<br />REG_IPCFIFORECV:  <br />ARM7 Fifo Registers:<br />REG_IPCFIFOCNT:     101<br />REG_IPCFIFORECV:  <br /><br /><br />数字是十六进制的，这显示FIFO因为接收和传送队列为空而禁用。<br /><br />2.使用以下代码，在R键按住并按下‘上’键时激活ARM9的FIFO。：<br /><br /><br />  if((keysHeld() & KEY_R) && (keysDown() & KEY_UP)) {<br />    REG_IPCFIFOCNT = IPC_FIFO_ENABLE | IPC_FIFO_SEND_CLEAR;<br />  }<br /><br /><br />屏幕更新后显示控制寄存器的第15位置位，激活FIFO，ARM7的值不改变：<br /><br /><br />ARM9 Fifo Registers:<br />REG_IPCFIFOCNT:     8101<br />REG_IPCFIFORECV:  <br />ARM7 Fifo Registers:<br />REG_IPCFIFOCNT:     101<br />REG_IPCFIFORECV:  <br /><br /><br />3.下一步按住R键不放并按下方向右键，使ARM9向REG_IPCFIFOSEND寄存器写入数据，记数变量增加：<br /><br /><br />  if((keysHeld() & KEY_R) && (keysDown() & KEY_RIGHT)) {<br />    static int count = 0;<br />    REG_IPCFIFOSEND = ++count;<br />  }<br /><br /><br />寄存器的改变显示在屏幕上，ARM9的控制寄存器的值改变为0x8100。唯一的改变是0位清零，表示传送队列不再为空。ARM7控制寄存器的值为 0x0001，第8位清零表示其接收队列不为空。我们只是放一些东西到ARM9的传送队列令其不为空，但还未对ARM7进行操作，所以它依然为空。<br /><br /><br />ARM9 Fifo Registers:<br />REG_IPCFIFOCNT:     8100<br />REG_IPCFIFORECV:  <br />ARM7 Fifo Registers:<br />REG_IPCFIFOCNT:     1<br />REG_IPCFIFORECV:  <br /><br /><br />4.让我们从ARM7端接收数据吧。首先我们需要激活ARM7的FIFO。按住L键并按下方向上键。使用于先前讲的ARM9的代码相似的代码写ARM7的REG_IPCFIFOCNT寄存器。寄存器的改变显示ARM7的控制寄存器的第15位置位，表示已激活：<br /><br /><br />ARM9 Fifo Registers:<br />REG_IPCFIFOCNT:     8100<br />REG_IPCFIFORECV:  <br />ARM7 Fifo Registers:<br />REG_IPCFIFOCNT:     8001<br />REG_IPCFIFORECV:  <br /><br /><br />5.按住L键并按下方向下键，这使ARM7读取REG_IPCFIFORECV的值并存储到一个ARM9可以显示的变量中。<br /><br /><br />arm7_fifo->recv = REG_IPCFIFORECV;<br /><br /><br />ARM9的控制寄存器的值变回8101，我们接收数据之后传送队列变为空状态。ARM7的值依然是8101。屏幕上显示ARM7的REG_IPCFIFORCV的值为ARM9传送的“1”。<br /><br /><br />ARM9 Fifo Registers:<br />REG_IPCFIFOCNT:     8101<br />REG_IPCFIFORECV:  <br />ARM7 Fifo Registers:<br />REG_IPCFIFOCNT:     8101<br />REG_IPCFIFORECV:   1<br /><br /><br />6. 尝试按住R键并按下方向右键16次，这导致对ARM9的传送队列的16次写操作-队列所能容纳的最大值。在第16次时ARM9的控制寄存器的值变为 0x8102。IPC_FIFO_SEND_FULL置位显示传送队列已满。ARM7的值为0x8201，表示IPC_FIFO_RECV_FULL 位置位，表示是接收队列已满。<br /><br /><br />ARM9 Fifo Registers:<br />REG_IPCFIFOCNT:     8102<br />REG_IPCFIFORECV:  <br />ARM7 Fifo Registers:<br />REG_IPCFIFOCNT:     8201<br />REG_IPCFIFORECV:   1<br /><br /><br />7. 按住L键并按下方向下键16次来完全清空队列。每按一次下应当以FIFO格式显示从ARM9传送的数字。所以应当是2，3, 4, 5, 等等。第一次会立即改变ARM9的控制寄存器为 0x8100 以及ARM7的变为0x8001因为队列满指示位清零。在第16次队列空指示位置位。<br /><br />8.尝试按住R键并按下方向左键16次来填充ARM9的队列并同样的填满ARM7的队列。之后在按方向下键前交替的使用R，L键来接收数据，一次一个，在ARM7和ARM9间交替。这表明每一个处理器的队列是独立的并且可以容纳16个项目。<br /><br />9.在队列为空时试着接收数据或向一个已满的队列传输项目，将会导致IPC_FIFO_ERROR位置位。<br /><br />执行：<br /><br />因为LIBNDS没有定义所有的与FIFO相关的东西，我创建了一个包含相关定义的fifo.h文件：<br /><br /><br />#define REG_IPCFIFOCNT (*(vu16*)0x4000184)<br />#define REG_IPCFIFOSEND (*(vu32*)0x4000188)<br />#define REG_IPCFIFORECV (*(vu32*)0x4100000)<br /><br />#define IPC_FIFO_SEND_EMPTY (1<<0)<br />#define IPC_FIFO_SEND_FULL (1<<1)<br />#define IPC_FIFO_SEND_IRQ   (1<<2)<br />#define IPC_FIFO_SEND_CLEAR (1<<3)<br />#define IPC_FIFO_RECV_EMPTY (1<<8)<br />#define IPC_FIFO_RECV_FULL (1<<9)<br />#define IPC_FIFO_RECV_IRQ   (1<<10)<br />#define IPC_FIFO_ERROR     (1<<14)<br />#define IPC_FIFO_ENABLE   (1<<15)<br /><br /><br />演示程序将显示两个CPU的控制寄存器的内容：<br /><br /><br />consolePrintf("ARM9 Fifo Registers:<br />");<br />consolePrintf("REG_IPCFIFOCNT:   %x<br />", REG_IPCFIFOCNT);<br />consolePrintf("REG_IPCFIFORCV:   %x<br />", arm9_recv);<br /><br />consolePrintf("ARM7 Fifo Registers:<br />");<br />consolePrintf("REG_IPCFIFOCNT:   %x<br />", arm7_fifo->cnt);<br />consolePrintf("REG_IPCFIFORCV:   %x<br />", arm7_fifo->recv);<br /><br /><br />'recv' ，寄存器的值储存在一个变量中，在指定按键按下时读取。因为我不能破坏性的读取寄存器（对寄存器的读取会将数据移出）。由ARM9处理按键的代码：<br /><br /><br />  scanKeys();<br />  // ARM9 Keys<br />  if((keysHeld() & KEY_R) && (keysDown() & KEY_UP)) {<br />    REG_IPCFIFOCNT = IPC_FIFO_ENABLE | IPC_FIFO_SEND_CLEAR;<br />  }<br />  if((keysHeld() & KEY_R) && (keysDown() & KEY_RIGHT)) {<br />    static int count = 0;<br />    REG_IPCFIFOSEND = ++count;<br />  }<br />  if((keysHeld() & KEY_R) && (keysDown() & KEY_DOWN)) {<br />    arm9_recv = REG_IPCFIFORECV;<br />  }<br /><br /><br /><br /><br />对ARM7 的寄存器的读写，我们需要用ARM9处理按键操作并告诉ARM7将寄存器的值储存或读取一个值。对这个FIFO会是个不错的主意，但我们这里使用教程6中使用的 'control' 结构，我们使用读写寄存器操作替代播放声音操作。这些代码包含在command.h, command7.cpp 和 command9.cpp中。ARM7代码如下：<br /><br /><br />static void CommandFIFOInit()<br />{<br />REG_IPCFIFOCNT = IPC_FIFO_ENABLE | IPC_FIFO_SEND_CLEAR;<br />}<br /><br />static void CommandFIFOSend()<br />{<br />static int count = 0;<br />REG_IPCFIFOSEND = ++count;<br />}<br /><br />static void CommandFIFORecv()<br />{<br />arm7_fifo->recv = REG_IPCFIFORECV;<br />}<br /><br />void CommandProcessCommands() {<br />static int currentCommand = -1;<br /><br />while(currentCommand != commandControl->currentCommand) {<br />  Command* command = &commandControl->command[currentCommand];<br />  switch(command->commandType) {<br />  case FIFO_INIT:<br />    CommandFIFOInit();<br />    break;    <br />  case FIFO_SEND:<br />    CommandFIFOSend();<br />    break;    <br />  case FIFO_RECV:<br />    CommandFIFORecv();<br />    break;    <br />  }<br />  currentCommand++;<br />  currentCommand &= MAX_COMMANDS-1;<br />}<br />}<br /><br /><br />它们在按键按下时由ARM9传送：<br /><br /><br />void CommandFIFOInit()<br />{<br />Command* command = &commandControl->command[commandControl-<br /><br />>currentCommand];<br />command->commandType = FIFO_INIT;<br />commandControl->currentCommand++;<br />commandControl->currentCommand &= MAX_COMMANDS-1;<br />}<br /><br />void CommandFIFOSend()<br />{<br />Command* command = &commandControl->command[commandControl-<br /><br />>currentCommand];<br />command->commandType = FIFO_SEND;<br />commandControl->currentCommand++;<br />commandControl->currentCommand &= MAX_COMMANDS-1;<br />}<br /><br />void CommandFIFORecv()<br />{<br />Command* command = &commandControl->command[commandControl-<br /><br />>currentCommand];<br />command->commandType = FIFO_RECV;<br />commandControl->currentCommand++;<br />commandControl->currentCommand &= MAX_COMMANDS-1;<br />}<br /><br />int main() {<br />  [...]<br />  // ARM7 Keys<br />  if((keysHeld() & KEY_L) && (keysDown() & KEY_UP)) {<br />    CommandFIFOInit();<br />  }<br />  if((keysHeld() & KEY_L) && (keysDown() & KEY_RIGHT)) {<br />    CommandFIFOSend();<br />  }<br />  if((keysHeld() & KEY_L) && (keysDown() & KEY_DOWN)) {<br />    CommandFIFORecv();<br />  }<br />  [...]<br />}<br /><br /><br />你注意到了ARM7的代码中设置了一个‘an arm7_fifo 结构’成员变量，这是一个用来在共享内存中的数据，为了方便存取。代码定义在transfer.h中:<br /><br /><br />/* Quick and dirty code to allow the ARM7 to inform the ARM9 of the<br />  current values of the FIFO registers */<br />struct ARM7_FIFO {<br />uint32 cnt;<br />uint32 send;<br />uint32 recv;<br />};<br /><br />#define arm7_fifo ((ARM7_FIFO*)((uint32)(IPC)+sizeof(TransferRegion)<br /><br />+sizeof(CommandControl)))<br /><br /><br /><br />以上就是FIFO详细讲解，在程序设计中FIFO会带来很多方便。<br /><br />如有疏漏错误之处，还望大家多多指正！</p>
</div>
</div>


            
            <div class="row">
                <nav aria-label="Page navigation example">
                    <ul class="pagination justify-content-center">
                    <!--<li class="page-item disabled">
                        <a class="page-link">Previous</a>
                    </li>
                    <li class="page-item"><a class="page-link" href="#">1</a></li>
                    <li class="page-item"><a class="page-link" href="#">2</a></li>
                    <li class="page-item"><a class="page-link" href="#">3</a></li>
                    <li class="page-item">
                        <a class="page-link" href="#">Next</a>
                    </li>
                        -->
                        <li class="page-item active">
<a class="page-link" href="post16968_1.html">1</a>
</li>


                    </ul>
                </nav>
            </div>
        </div>


        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    </body>
</html>

