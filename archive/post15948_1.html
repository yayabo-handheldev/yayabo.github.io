
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>lua 协同程序 实现</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    </head>

    <body style="margin-top:1.618%">
        <div class="container">
            <div class="row">
                <div class="jumbotron">
                    <h1 class="display-5">lua 协同程序 实现</h1>
                </div>
                <br />
                <nav class="nav">
                    <a class="nav-link active" aria-current="page" href="index_16.html">返回</a>
                </nav>
            </div>

            <hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2010-01-18 20:46:08</p>
</div>
<div class="col-10">
<p>协同程序（coroutine）与多线程情况下的线程比较类似：有自己的堆栈，自己的局部变量，有自己的指令指针（IP，instruction pointer），但与其它协同程序共享全局变量等很多信息。线程和协同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只在必要时才会被挂起。<br />协同是非常强大的功能，但是用起来也很复杂。如果你是第一次阅读本章，某些例子可能会不大理解，不必担心，可先继续阅读后面的章节，再回头琢磨本章内容。<br />9.1 协同的基础<br />Lua的所有协同函数存放于coroutine table中。create函数用于创建新的协同程序，其只有一个参数：一个函数，即协同程序将要运行的代码。若一切顺利，返回值为thread类型，表示创建成功。通常情况下，create的参数是匿名函数：<br />co = coroutine.create(function ()<br />    print("hi")<br />end)<br /><br />print(co)    --> thread: 0x8071d98<br />协同有三个状态：挂起态（suspended）、运行态（running）、停止态（dead）。当我们创建协同程序成功时，其为挂起态，即此时协同程序并未运行。我们可用status函数检查协同的状态：<br />print(coroutine.status(co))    --> suspended<br />函数coroutine.resume使协同程序由挂起状态变为运行态：<br />coroutine.resume(co)            --> hi<br />本例中，协同程序打印出"hi"后，任务完成，便进入终止态：<br />print(coroutine.status(co))    --> dead<br />当目前为止，协同看起来只是一种复杂的调用函数的方式，真正的强大之处体现在yield函数，它可以将正在运行的代码挂起，看一个例子：<br />co = coroutine.create(function ()<br />    for i=1,10 do<br />      print("co", i)<br />      coroutine.yield()<br />    end<br />end)<br />执行这个协同程序，程序将在第一个yield处被挂起：<br />coroutine.resume(co)            --> co  1<br />print(coroutine.status(co))    --> suspended<br />从协同的观点看：使用函数yield可以使程序挂起，当我们激活被挂起的程序时，将从函数yield的位置继续执行程序，直到再次遇到yield或程序结束。<br />coroutine.resume(co)    --> co  2<br />coroutine.resume(co)    --> co  3<br />...<br />coroutine.resume(co)    --> co  10<br />coroutine.resume(co)    -- prints nothing<br />上面最后一次调用时，协同体已结束，因此协同程序处于终止态。如果我们仍然希望激活它，resume将返回false和错误信息。<br />print(coroutine.resume(co))<br />        --> false  cannot resume dead coroutine<br />注意：resume运行在保护模式下，因此，如果协同程序内部存在错误，Lua并不会抛出错误，而是将错误返回给resume函数。<br />Lua中协同的强大能力，还在于通过resume-yield来交换数据。<br />第一个例子中只有resume，没有yield，resume把参数传递给协同的主程序。<br />co = coroutine.create(function (a,b,c)<br />    print("co", a,b,c)<br />end)<br />coroutine.resume(co, 1, 2, 3)      --> co 1 2 3<br />第二个例子，数据由yield传给resume。true表明调用成功，true之后的部分，即是yield的参数。<br />co = coroutine.create(function (a,b)<br />    coroutine.yield(a + b, a - b)<br />end)<br />print(coroutine.resume(co, 20, 10))    --> true 30 10<br />相应地，resume的参数，会被传递给yield。<br />co = coroutine.create (function ()<br />    print("co", coroutine.yield())<br />end)<br />coroutine.resume(co)<br />coroutine.resume(co, 4, 5)      --> co 4 5<br />最后一个例子，协同代码结束时的返回值，也会传给resume：<br />co = coroutine.create(function ()<br />    return 6, 7<br />end)<br />print(coroutine.resume(co))    --> true 6 7<br />我们很少在一个协同程序中同时使用多个特性，但每一种都有用处。<br />现在已大体了解了协同的基础内容，在我们继续学习之前，先澄清两个概念：Lua的协同称为不对称协同（asymmetric coroutines），指“挂起一个正在执行的协同函数”与“使一个被挂起的协同再次执行的函数”是不同的，有些语言提供对称协同（symmetric coroutines），即使用同一个函数负责“执行与挂起间的状态切换”。<br />有人称不对称的协同为半协同，另一些人使用同样的术语表示真正的协同，严格意义上的协同不论在什么地方只要它不是在其他的辅助代码内部的时候都可以并且只能使执行挂起，不论什么时候在其控制栈内都不会有不可决定的调用。（However, other people use the same term semi-coroutine to denote a restricted implementation of coroutines, where a coroutine can only suspend its execution when it is not inside any auxiliary function, that is, when it has no pending calls in its control stack.）。只有半协同程序内部可以使用yield，python中的产生器（generator）就是这种类型的半协同。<br />与对称的协同和不对称协同的区别不同的是，协同与产生器的区别更大。产生器相对比较简单，他不能完成真正的协同所能完成的一些任务。我们熟练使用不对称的协同之后，可以利用不对称的协同实现比较优越的对称协同。<br />9.2 管道和过滤器<br />协同最具代表性的例子是用来解决生产者-消费者问题。假定有一个函数不断地生产数据（比如从文件中读取），另一个函数不断的处理这些数据（比如写到另一文件中），函数如下：<br />function producer ()<br />    while true do<br />      local x = io.read()      -- produce new value<br />      send(x)                  -- send to consumer<br />    end<br />end<br /><br />function consumer ()<br />    while true do<br />      local x = receive()      -- receive from producer<br />      io.write(x, "<br />")        -- consume new value<br />    end<br />end<br />（例子中生产者和消费者都在不停的循环，修改一下使得没有数据的时候他们停下来并不困难），问题在于如何使得receive和send协同工作。只是一个典型的谁拥有主循环的情况，生产者和消费者都处在活动状态，都有自己的主循环，都认为另一方是可调用的服务。对于这种特殊的情况，可以改变一个函数的结构解除循环，使其作为被动的接受。然而这种改变在某些特定的实际情况下可能并不简单。<br />协同为解决这种问题提供了理想的方法，因为调用者与被调用者之间的 resume-yield关系会不断颠倒。当一个协同调用yield时并不会进入一个新的函数，取而代之的是返回一个未决的resume的调用。相似的，调用resume时也不会开始一个新的函数而是返回yield的调用。这种性质正是我们所需要的，与使得send-receive协同工作的方式是一致的。receive唤醒生产者生产新值，send把产生的值送给消费者消费。<br />function receive ()<br />    local status, value = coroutine.resume(producer)<br />    return value<br />end<br /><br />function send (x)<br />    coroutine.yield(x)<br />end<br /><br />producer = coroutine.create( function ()<br />    while true do<br />      local x = io.read()      -- produce new value<br />      send(x)<br />    end<br />end)<br />这种设计下，开始时调用消费者，当消费者需要值时他唤起生产者生产值，生产者生产值后停止直到消费者再次请求。我们称这种设计为消费者驱动的设计。<br />我们可以使用过滤器扩展这个设计，过滤器指在生产者与消费者之间，可以对数据进行某些转换处理。过滤器在同一时间既是生产者又是消费者，他请求生产者生产值并且转换格式后传给消费者，我们修改上面的代码加入过滤器（给每一行前面加上行号）。完整的代码如下：<br />function receive (prod)<br />    local status, value = coroutine.resume(prod)<br />    return value<br />end<br /><br />function send (x)<br />    coroutine.yield(x)<br />end<br /><br />function producer ()<br />    return coroutine.create(function ()<br />      while true do<br />          local x = io.read()      -- produce new value<br />          send(x)<br />      end<br />    end)<br />end<br /><br />function filter (prod)<br />    return coroutine.create(function ()<br />      local line = 1<br />      while true do<br />          local x = receive(prod) -- get new value<br />          x = string.format("%5d %s", line, x)<br />          send(x)      -- send it to consumer<br />          line = line + 1<br />      end<br />    end)<br />end<br /><br />function consumer (prod)<br />    while true do<br />      local x = receive(prod) -- get new value<br />      io.write(x, "<br />")        -- consume new value<br />    end<br />end<br />可以调用：<br />p = producer()<br />f = filter(p)<br />consumer(f)<br />或者：<br />consumer(filter(producer()))<br />看完上面这个例子你可能很自然的想到UNIX的管道，协同是一种非抢占式的多线程。管道的方式下，每一个任务在独立的进程中运行，而协同方式下，每个任务运行在独立的协同代码中。管道在读（consumer）与写（producer）之间提供了一个缓冲，因此两者相关的的速度没有什么限制，在上下文管道中这是非常重要的，因为在进程间的切换代价是很高的。协同模式下，任务间的切换代价较小，与函数调用相当，因此读写可以很好的协同处理。<br />9.3 用作迭代器的协同<br />我们可以将循环的迭代器看作生产者-消费者模式的特殊的例子。迭代函数产生值给循环体消费。所以可以使用协同来实现迭代器。协同的一个关键特征是它可以不断颠倒调用者与被调用者之间的关系，这样我们毫无顾虑的使用它实现一个迭代器，而不用保存迭代函数返回的状态。<br />我们来完成一个打印一个数组元素的所有的排列来阐明这种应用。直接写这样一个迭代函数来完成这个任务并不容易，但是写一个生成所有排列的递归函数并不难。思路是这样的：将数组中的每一个元素放到最后，依次递归生成所有剩余元素的排列。代码如下：<br />function permgen (a, n)<br />    if n == 0 then<br />      printResult(a)<br />    else<br />      for i=1,n do<br /><br />          -- put i-th element as the last one<br />          a[n], a = a, a[n]<br /><br />          -- generate all permutations of the other elements<br />          permgen(a, n - 1)<br /><br />          -- restore i-th element<br />          a[n], a = a, a[n]<br /><br />      end<br />    end<br />end<br /><br />function printResult (a)<br />    for i,v in ipairs(a) do<br />      io.write(v, " ")<br />    end<br />    io.write("<br />")<br />end<br /><br />permgen ({1,2,3,4}, 4)<br />有了上面的生成器后，下面我们将这个例子修改一下使其转换成一个迭代函数：<br />1. 第一步printResult 改为 yield<br />function permgen (a, n)<br />    if n == 0 then<br />      coroutine.yield(a)<br />    else<br />      ...<br />2. 第二步，我们定义一个迭代工厂，修改生成器在生成器内创建迭代函数，并使生成器运行在一个协同程序内。迭代函数负责请求协同产生下一个可能的排列。<br />function perm (a)<br />    local n = table.getn(a)<br />    local co = coroutine.create(function () permgen(a, n) end)<br />    return function ()  -- iterator<br />      local code, res = coroutine.resume(co)<br />      return res<br />    end<br />end<br />这样我们就可以使用for循环来打印出一个数组的所有排列情况了：<br />for p in perm{"a", "b", "c"} do<br />    printResult(p)<br />end<br />--> b c a<br />--> c b a<br />--> c a b<br />--> a c b<br />--> b a c<br />--> a b c<br />perm 函数使用了Lua中常用的模式：将一个对协同的resume的调用封装在一个函数内部，这种方式在Lua非常常见，所以Lua专门为此专门提供了一个函数 coroutine.wrap。与create相同的是，wrap创建一个协同程序；不同的是wrap不返回协同本身，而是返回一个函数，当这个函数被调用时将resume协同。wrap中resume协同的时候不会返回错误代码作为第一个返回结果，一旦有错误发生，将抛出错误。我们可以使用wrap重写 perm：<br />function perm (a)<br />    local n = table.getn(a)<br />    return coroutine.wrap(function () permgen(a, n) end)<br />end<br />一般情况下，coroutine.wrap比coroutine.create使用起来简单直观，前者更确切的提供了我们所需要的：一个可以resume协同的函数，然而缺少灵活性，没有办法知道wrap所创建的协同的状态，也没有办法检查错误的发生。<br />9.4 非抢占式多线程<br />如前面所见，Lua中的协同是一协作的多线程，每一个协同等同于一个线程，yield-resume可以实现在线程中切换。然而与真正的多线程不同的是，协同是非抢占式的。当一个协同正在运行时，不能在外部终止他。只能通过显示的调用yield挂起他的执行。对于某些应用来说这个不存在问题，但有些应用对此是不能忍受的。不存在抢占式调用的程序是容易编写的。不需要考虑同步带来的bugs，因为程序中的所有线程间的同步都是显示的。你仅仅需要在协同代码超出临界区时调用yield即可。<br />对非抢占式多线程来说，不管什么时候只要有一个线程调用一个阻塞操作（blocking operation），整个程序在阻塞操作完成之前都将停止。对大部分应用程序而言，只是无法忍受的，这使得很多程序员离协同而去。下面我们将看到这个问题可以被有趣的解决。<br />看一个多线程的例子：我们想通过http协议从远程主机上下在一些文件。我们使用Diego Nehab开发的LuaSocket库来完成。我们先看下在一个文件的实现，大概步骤是打开一个到远程主机的连接，发送下载文件的请求，开始下载文件，下载完毕后关闭连接。<br />第一，加载LuaSocket库<br />require "luasocket"<br />第二，定义远程主机和需要下载的文件名<br />host = "www.w3.org"<br />file = "/TR/REC-html32.html"<br />第三，打开一个TCP连接到远程主机的80端口（http服务的标准端口）<br />c = assert(socket.connect(host, 80))<br />上面这句返回一个连接对象，我们可以使用这个连接对象请求发送文件<br />c:send("GET " .. file .. " HTTP/1.0<br /><br />")<br />receive函数返回他送接收到的数据加上一个表示操作状态的字符串。当主机断开连接时，我们退出循环。<br />第四，关闭连接<br />c:close()<br />现在我们知道了如何下载一个文件，下面我们来看看如何下载多个文件。一种方法是我们在一个时刻只下载一个文件，这种顺序下载的方式必须等前一个文件下载完成后一个文件才能开始下载。实际上是，当我们发送一个请求之后有很多时间是在等待数据的到达，也就是说大部分时间浪费在调用receive上。如果同时可以下载多个文件，效率将会有很大提高。当一个连接没有数据到达时，可以从另一个连接读取数据。很显然，协同为这种同时下载提供了很方便的支持，我们为每一个下载任务创建一个线程，当一个线程没有数据到达时，他将控制权交给一个分配器，由分配器唤起另外的线程读取数据。<br />使用协同机制重写上面的代码，在一个函数内：<br />function download (host, file)<br />    local c = assert(socket.connect(host, 80))<br />    local count = 0      -- counts number of bytes read<br />    c:send("GET " .. file .. " HTTP/1.0<br /><br />")<br />    while true do<br />      local s, status = receive&copy;<br />      count = count + string.len(s)<br />      if status == "closed" then break end<br />    end<br />    c:close()<br />    print(file, count)<br />end<br />由于我们不关心文件的内容，上面的代码只是计算文件的大小而不是将文件内容输出。（当有多个线程下载多个文件时，输出会混杂在一起），在新的函数代码中，我们使用receive从远程连接接收数据，在顺序接收数据的方式下代码如下：<br />function receive (connection)<br />    return connection:receive(2^10)<br />end<br />在同步接受数据的方式下，函数接收数据时不能被阻塞，而是在没有数据可取时yield，代码如下：<br />function receive (connection)<br />    connection:timeout(0)    -- do not block<br />    local s, status = connection:receive(2^10)<br />    if status == "timeout" then<br />      coroutine.yield(connection)<br />    end<br />    return s, status<br />end<br />调用函数timeout(0)使得对连接的任何操作都不会阻塞。当操作返回的状态为timeout时意味着操作未完成就返回了。在这种情况下，线程 yield。非false的数值作为yield的参数告诉分配器线程仍在执行它的任务。（后面我们将看到分配器需要timeout连接的情况），注意:即使在timeout模式下，连接依然返回他接受到直到timeout为止，因此receive会一直返回s给她的调用者。<br />下面的函数保证每一个下载运行在自己独立的线程内：<br />threads = {}      -- list of all live threads<br />function get (host, file)<br />    -- create coroutine<br />    local co = coroutine.create(function ()<br />      download(host, file)<br />    end)<br />    -- insert it in the list<br />    table.insert(threads, co)<br />end<br />代码中table中为分配器保存了所有活动的线程。<br />分配器代码是很简单的，它是一个循环，逐个调用每一个线程。并且从线程列表中移除已经完成任务的线程。当没有线程可以运行时退出循环。<br />function dispatcher ()<br />    while true do<br />      local n = table.getn(threads)<br />      if n == 0 then break end    -- no more threads to run<br />      for i=1,n do<br />          local status, res = coroutine.resume(threads)<br />          if not res then  -- thread finished its task?<br />              table.remove(threads, i)<br />              break<br />          end<br />      end<br />    end<br />end<br />最后，在主程序中创建需要的线程调用分配器，例如：从W3C站点上下载4个文件：<br />host = "www.w3c.org"<br /><br />get(host, "/TR/html401/html40.txt")<br />get(host, "/TR/2002/REC-xhtml1-20020801/xhtml1.pdf")<br />get(host, "/TR/REC-html32.html")<br />get(host,<br />    "/TR/2000/REC-DOM-Level-2-Core-20001113/DOM2-Core.txt")<br /><br />dispatcher()      -- main loop<br />使用协同方式下，我的机器花了6s下载完这几个文件；顺序方式下用了15s，大概2倍的时间。<br />尽管效率提高了，但距离理想的实现还相差甚远，当至少有一个线程有数据可读取的时候，这段代码可以很好的运行。否则，分配器将进入忙等待状态，从一个线程到另一个线程不停的循环判断是否有数据可获取。结果协同实现的代码比顺序读取将花费30倍的CPU时间。<br />为了避免这种情况出现，我们可以使用LuaSocket库中的select函数。当程序在一组socket中不断的循环等待状态改变时，它可以使程序被阻塞。我们只需要修改分配器，使用select函数修改后的代码如下：<br />function dispatcher ()<br />    while true do<br />      local n = table.getn(threads)<br />      if n == 0 then break end    -- no more threads to run<br />      local connections = {}<br />      for i=1,n do<br />          local status, res = coroutine.resume(threads)<br />          if not res then  -- thread finished its task?<br />              table.remove(threads, i)<br />              break<br />          else  -- timeout<br />              table.insert(connections, res)<br />          end<br />      end<br />      if table.getn(connections) == n then<br />          socket.select(connections)<br />      end<br />    end<br />end<br />在内层的循环分配器收集连接表中timeout地连接，注意：receive将连接传递给yield，因此resume返回他们。当所有的连接都 timeout分配器调用select等待任一连接状态的改变。最终的实现效率和上一个协同实现的方式相当，另外，他不会发生忙等待，比起顺序实现的方式消耗CPU的时间仅仅多一点点。</p>
</div>
</div>


            
            <div class="row">
                <nav aria-label="Page navigation example">
                    <ul class="pagination justify-content-center">
                    <!--<li class="page-item disabled">
                        <a class="page-link">Previous</a>
                    </li>
                    <li class="page-item"><a class="page-link" href="#">1</a></li>
                    <li class="page-item"><a class="page-link" href="#">2</a></li>
                    <li class="page-item"><a class="page-link" href="#">3</a></li>
                    <li class="page-item">
                        <a class="page-link" href="#">Next</a>
                    </li>
                        -->
                        <li class="page-item active">
<a class="page-link" href="post15948_1.html">1</a>
</li>


                    </ul>
                </nav>
            </div>
        </div>


        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    </body>
</html>

