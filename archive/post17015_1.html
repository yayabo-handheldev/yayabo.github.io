
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>NDS开发Wiki翻译：第六天：设备相关的运算（2）</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    </head>

    <body style="margin-top:1.618%">
        <div class="container">
            <div class="row">
                <div class="jumbotron">
                    <h1 class="display-5">NDS开发Wiki翻译：第六天：设备相关的运算（2）</h1>
                </div>
                <br />
                <nav class="nav">
                    <a class="nav-link active" aria-current="page" href="index_18.html">返回</a>
                </nav>
            </div>

            <hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-06 16:07:02</p>
</div>
<div class="col-10">
<p>摘自：chenyi1976.spaces.live.com<br />翻译：陈轶<br /><br />使用重力(实现跳跃等效果)<br /><br />请务必已经读过定点数教学部分。。。代码很简单，你可以用于任何类型的游戏。。。你必须懂得一些定点数的运算，否则可能看不懂下面的东东。<br /><br />"重力"的代码非常不错，因为它可以用在很多的游戏中，特别是类似于超级马里奥那种。。。它有一个基本原则：你的精灵（或马里奥或玩家或任何东西）有垂直速度的时候，"重力"代码能够给予这个速度以加速度。下面有3件事情：<br /><br />    * 每次转身，速度根据它的加速度进行变化<br />    * 每次转身，精灵的位置根据它的速度而变化<br />    * 任何时候，如果你的精灵碰到地面（或在地面以下），它应该放到地面上来，并且速度应该归零。。。。<br /><br />因为速度和加速度有很多值，我们也不希望给它们增加限制，我们将使用定点数。。。这就是你为什么要使用移位操作的原因（&laquo;8和&raquo;8这种操作 ）。这个例子是演示一个小飞船上升，下降。你能够改变重力和启动力（相当于跳跃）来看看飞船的不同效果。<br /><br />#define FLOOR (160<<8) // Floor y level<br /><br />int main(void){<br /><br />PA_Init(); //PAlib inits<br />PA_InitVBL();<br /><br />PA_InitText(1, 0);<br /><br />PA_OutputText(1, 2, 4, "Press A to take off !");<br />PA_OutputText(1, 2, 5, "Gravity change : Left/Right");<br />PA_OutputText(1, 2, 7, "Takeoff Speed change : Up/Down");<br /><br />PA_LoadSpritePal(0, 0, (void*)sprite0_Pal)<br /><br />PA_CreateSprite(0, 0, (void*)vaisseau_Sprite, OBJ_SIZE_32X32, 1, 0, 50, 50);<br /><br /><br />s32 gravity = 32; // change the gravity and check the result :)<br />s32 velocity_y = 0;<br />s32 spritey = FLOOR; // at the bottom<br />s32 takeoffspeed = 1000; // Takeoff speed...<br /><br />while(1) // Infinite loops<br />{<br /><br />takeoffspeed += (Pad.Held.Up - Pad.Held.Down)*8; // Change takeoff speed...<br />gravity += (Pad.Held.Right - Pad.Held.Left)*2; // Change gravity speed...<br /><br />PA_OutputText(1, 4, 8, "Takeoff speed : %d ", takeoffspeed);<br />PA_OutputText(1, 4, 6, "Gravity : %d ", gravity);<br /><br />if((spritey <= FLOOR) && Pad.Newpress.A) { // You can jump if not in the air...<br />velocity_y = -takeoffspeed; // Change the base speed to see the result...<br />}<br /><br />// Moves all the time...<br />velocity_y += gravity; // Gravity...<br />spritey += velocity_y; // Speed...<br /><br />if(spritey >= FLOOR) // Gets to the floor !<br />{<br />velocity_y = 0;<br />spritey = FLOOR;<br />}<br /><br />PA_OutputText(1, 0, 0, "Y : %d <br />VY : %d ", spritey, velocity_y);<br /><br />if (spritey>>8 > -32) PA_SetSpriteY(0, 0, spritey>>8); // show if on screen<br />else PA_SetSpriteY(0, 0, 192);<br /><br />PA_WaitForVBL();<br />}<br /><br />return 0;<br />}<br /><br />下面解释一下：<br /><br />    * #define FLOOR (160&laquo;8)</p>
</div>
</div>

<hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-06 16:21:30</p>
</div>
<div class="col-10">
<p>　　其实我们之前的程序已多少用到了一些表达式，现在我们就深入的学习一下。有些我们已经熟悉了，比如“if”语句和“>”运算符。我们将编写一个利用这些表达式的程序，它与我们上一次写的很相似，只是更深一些。先创建一个新文件，但暂时不要添加代码，除非得到明确告知，象上一讲一样。<br /><br />　　首先要讲的就是算术表达式，太简单了，无非就是加减乘除而已。我也不多说了，举例如下：<br /><br />代码:<br />x = 3 + 5 -- 加法<br />y = 3 - 1 -- 减法<br />a = 4 * 5 -- 乘法<br />b = 10 / 2 -- 除法<br />c = 2 ^ 8 -- 乘方<br /><br />　　不难吧，嗯？记住，我教你的都是基础，我不会介绍每一个命令。等你学会了我传授的，你就能自己查询资料，学习我没有教的东西了。<br /><br />　　接着要讲的是关系表达式。这是编程时超常用的，用来比较数据。返回真或假（又称为布尔值）。下面是列表：<br /><br />　　== (相等)<br />　　~= (不相等)<br />　　< (小于)<br />　　> (大于)<br />　　<= (小于或等于)<br />　　>= (大于或等于)<br /><br />　　用这些就能检查各种有用的信息。例如，如果一个敌兵的生命值是0，他是不是就该死去了呢？或者检查一下我们是否够钱买下那把新剑！当然光靠这些运算符还是不行的，大多数情况下我们还需要下一组新的表达式。<br /><br />　　我的最爱第一个，“if”语句。用来检测某个条件是否为真，如果是则执行一段代码。还可以增加功能，如果条件不满足则做另一件事。简单的“if”表达式如下：<br /><br />代码:<br />if <某条件> then<br /><执行某代码><br />end<br /><br />　　现在举个现实的例子。假设有个程序设了两个变量，myCash 和 itemCost。myCash 是我们拥有的金钱数，itemCost 则是我们想要购买的物品价格。在游戏中我们需要检查是否有足够的钱购买该物品。如果有，则从总金钱数中扣除，打印一条已购买消息到屏幕上。如果钱不够，则打印一则消息到屏幕，通知玩家不够钱买。代码应该跟下面的差不多：<br /><br />代码:<br />myCash = 253<br />itemCost = 100<br /><br />if myCash > itemCost then<br />myCash = myCash - itemCost<br />screen:print(100,100,"Item Bought",blue)<br />else<br />screen:print(100,100,"Not enough money",blue)<br />end<br /><br />　　让我们分析一下。首先，我们设了两个变量，告知我们有多少钱，和物品值多少钱。然后是我们的if表达式，其含义等同于 "if 253 > 100 then"，就是问变量 myCash 的值是否大于变量 itemCost 的值。如果是...则运行下一行，获取 itemCost 的值并将其从 myCash 的值中扣除。换言之就是 253-100，然后将答案存于 myCash。接着下一行则是打印字串“Item Bought”至屏幕。在下一行我们用了"else"，即随后代码将在 myCash 不大于 itemCost 时执行，在此情况下它将打印字符串 "Not enough money" 至屏幕。最后，自然还是“end”，结束整个表达式。<br /><br />　　在上例中，我们有足够的钱购买那个物品。因此“else”段的代码不会被执行。许多时候你甚至不需要使用else，有时你则需要使用多个else。这种情况下你可以使用“elseif”。兹举一例：<br /><br />代码:<br />myNumber = 4<br />if myNumber == 1 then<br />screen:print(100,100,"Your lucky number is 1",blue)<br />elseif myNumber == 2 then<br />screen:print(100,100,"Your lucky number is 2",blue)<br />elseif myNumber == 3 then<br />screen:print(100,100,"Your lucky number is 3",blue)<br />else<br />screen:print(100,100,"Your number isn't very lucky!",blue)<br />end<br /><br />　　这段代码检查 myNumber 是否等于 1、2 或 3。如果是，则打印“Your lucky number is (number)”。但是如果 myNumber 不等于 1、2 或 3 则打印“Your number isn't very lucky”。注意，此例程可以简单化，只用一个 else 无需 elseif，只要改成“if myNumber > 0 and myNumber < 4 then”即可。接下来就让我们学一学“and”关键字和其他的知识。<br /><br />　　如上所述，逻辑运算符可以用来比较多个事物。我们将学习其中两个，“and”和“or”。还有一个“not”。<br /><br />　　假设你在编写一个角色扮演游戏，有点象 Diablo 那种。游戏的玩家角色想要装备一把屠龙刀（Dragon Slayer）。你打算设定玩家只有达到20级且是战士（warrior）类时方能装备该物品。在程序开始我们创建一个数列存放这些信息，例如：<br /><br />代码:<br />Player = { }<br />Player[1] = { level = 15, class = "warrior", weapon = "knife" }<br /><br />　　稍后我们的代码将检查玩家是否有资格装备该武器，如下：<br /><br />代码:<br />if Player[1].level >= 20 and Player[1].class == "warrior" then<br />Player[1].weapon = "Dragon Slayer"<br />end<br /><br />　　第一行检查玩家的等级是否大于或等于 20，还有玩家的类别是否属于战士类。如果两个条件都满足，则玩家的武器就被设定为屠龙刀。如果只有一个条件满足，则返回值为假，那么武器就不会变更。在本例中，我们的玩家虽然的确是战士类，但是等级只有15，没有大于或等于 20，所以该玩家无法使用屠龙刀。你可以使用不止一个“and”，例如你可以这样写：<br /><br />代码:<br />if hat == "blue" and shirt == "red" and age > 15 and state ~= "Florida" then<br />screen:print(100,100,"You are accepted!",yellow)<br />end<br /><br />　　使用“or”的方法完全一样，除了只需要其中一个条件满足返回值即为真以外。例如：<br /><br />代码:<br />myCar = "Mustang"<br /><br />if myCar == "Corvette" or myCar == "Mustang" then<br />screen:print(10,20,"Nice car!",green)<br />end<br /><br />　　本例检查 myCar 是否等于 Corvette 或 myCar 是否等于 Mustang。二者只要有一个为真，程序就打印“Nice Car!”到屏幕上。myCar 不等于 Corvette 但等于 Mustang，所以返回值为真。<br /><br />　　那么，让我们付诸行动吧。我们还是用上一讲编写的程序，用我们今天学的修改一下。现在打开那个文件。什么？你扔掉了？别着急，去下载上一讲的附件吧。<br /><br />　　上一讲中，我们设定每次按下 X 键时减去敌兵生命值 5 点。本课我们将添加一些表达式，让程序能在当前敌兵死亡时让另一个敌兵上阵。我们还得检查何时已无兵可用。<br /><br />　　第一件要做的就是添加一个变量，告知我们正与之作战的当前敌兵是哪个。我们会给该变量赋一个值。你该发现我们的敌兵数列有5个敌兵，由1至5分别索引。我们将用这些数字来指称这些敌兵。在代码顶端，绿色变量的下面，添加此变量：<br /><br />代码:<br />currentEnemy = 1<br /><br />　　现在我们添加一些代码，检查当前敌兵的生命值是否为 0，如果是则将 currentEnemy 变量的值递增 1，但是只在该值不超过 5 的情况下，也就是最后一个敌兵。在你的 if pad:cross() 代码行之上添加此代码：<br /><br />代码:<br />if Enemy[currentEnemy].health == 0 and currentEnemy <= 4 then<br />currentEnemy = currentEnemy + 1<br />end<br /><br />　　注意，此处我们用 currentEnemy 变量替代了数列 Enemy 中的数字。这样我们只要设置 currentEnemy 变量为正确的敌兵，那么代码中任何使用 Enemy 数列的地方都可以使用currentEnemy，而无需检查每个敌兵（(Enemy[1] Enemy[2] 等等...），这样代码更自动化。有了“<= 4”的检查项，currentEnemy 变量就不会超过 5。如此说来，我们得修改几行代码。找到下面几行：<br /><br />代码:<br />screen:print(250,10,"Enemy Health: " .. Enemy[1].health,green)<br />screen:print(250,20,"Enemy Type: " .. Enemy[1].type,green)<br /><br />修改为：<br /><br />代码:<br />screen:print(250,10,"Enemy Health: " .. Enemy[currentEnemy].health,green)<br />screen:print(250,20,"Enemy Type: " .. Enemy[currentEnemy].type,green)<br /><br />　　现在当敌兵变更时，程序会自动打印出正确敌兵的生命值和兵种。我们还需要修改下述两行：<br /><br />代码:<br />if pad:cross() and oldpad:cross() ~= pad:cross() and Enemy[1].health > 0 then<br />Enemy[1].health = Enemy[1].health - 5<br /><br />　　修改为：<br /><br />代码:<br />if pad:cross() and oldpad:cross() ~= pad:cross() and Enemy[currentEnemy].health > 0 then<br />Enemy[currentEnemy].health = Enemy[currentEnemy].health - 5<br /><br />　　作为结束，我们将添加一些代码，如果5个敌兵都被杀死则打印“All enemies are dead”至屏幕。把这个代码置于主循环中打印敌兵生命值和类型的screen:print行下。<br /><br />代码:<br />if currentEnemy == 5 and Enemy[currentEnemy].health == 0 then<br />screen:print(50,100,"All enemies are dead",green)<br />end<br /><br />　　这段代码是说，如果当前敌兵编号是 5 且其生命值等于 0 则打印“all enemies are dead”。保存你的代码，运行之。按下 X 直到一个敌兵死亡。然后下一个敌兵会上阵，一个跟一个，直到所有 5 个敌兵都被杀死为止。<br /><br />　　我希望本课能对你今后的表达式学习有所帮助。</p>
</div>
</div>

<hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-06 16:23:19</p>
</div>
<div class="col-10">
<p>　　到目前为止，我们所有的程序均只使用了文本。我想下水前先湿湿脚比较好，有了基本编程知识，将使一切容易领会。在本节课中，我将介绍使用图像，及一些获取图像信息的命令。<br /><br />　　至于我们打算编写什么？嗯，就做一个看起来真正象是游戏的程序吧。它不会做任何华而不实或令人兴奋的事情，但足够应付本教程的目的了，图像。我们这里所学的只是众多图像命令的一部分。我们将在以后的教程里进一步了解这些。你也可以自己在luaplayer的文档中查询。我们的作品将包括一个可移动的角色，他可以在屏幕中自由走动，但不能够走出屏幕边缘。<br /><br />　　第一件事是将下面提供的图像保存到你的工作目录。这些图像只是做个样本，你完全可以用自己的。LuaPlayer 可以载入 PNG 和 JPEG 图像。大多数情况下我会使用 PNG 而不选 JPEG，尤其当你需要透明的时候。现在保存这些图像：[url=http://down.tgbus.com/soft/20082.shtml]点此下载[/url]<br /><br />　　解压至工作目录。你应该有如下3个图像：<br /><br />　　player.png<br />　　grass.png<br />　　flower.png<br /><br />　　现在我们先回到教程的第一部分，稍后再编写我们的代码。<br /><br />载入图像<br /><br />　　要在lua中使用图像，你必须先将其载入程序，并赋予一个变量（或数据表）。你可以在程序开头这么做，也可以稍后再做，这取决于你什么时候需要该图像。在我们待会儿要写的代码中我们会在开始就预先载入图像。这里是一个载入图像的示例：<br /><br />代码:<br />grass = Image.load("grass.png")<br /><br />　　这一句将载入图像文件 "grass.png" 并赋予变量 "grass"。要正确载入图像你得确保该图像与你的lua脚本文件位于同一目录。如果你把图像放在一个子文件夹，例如 "Images"，你就得用 "Images/grass.png" 而不是 "grass.png"。大小写也不要搞错。image 的 I 要大写，load 的 l 要小写。载入图像很简单吧？！<br /><br />显示图像<br /><br />　　要在屏幕上真正显示图像并不比载入更难。这里是完整命令：<br /><br />代码:<br />screen:blit(x, y, Image source, [sourcex, sourcey, width, height], [alpha = true])<br /><br />　　这里有很多信息要填！不是所有的参数都必要，方括号里的如果你不需要你可以完全忽略。现在让我们解释一下。<br /><br />　　代码起始的 screen:blit 是一个命令，它将图像粘贴到屏幕上。<br /><br />　　括号里的内容是真正乐趣所在。<br /><br />　　x 和 y 与 print 命令中的相同。指定图像粘贴到屏幕上的位置。<br /><br />　　Image source 指定要粘贴的图像。上文中我们载入了一个图像叫 grass，所以我们可以用 grass 作为图像源。<br /><br />　　[sourcex, sourcey, width, height] 是可选的。用来载入某幅大图的一部分。分片图是个极好的例子。你可以载入一幅单图，分成好几个部分，使用此代码你可以只粘贴其中的一部分。sourcex 和 sourcey 是要截取区域开始点的 x 和 y 坐标值。这样粘贴的不是整幅图，而是其中一部分。<br /><br />　　width 和 height 是指图像截取区域的宽度和高度。<br /><br />　　命令的最后是 alpha 参数。这是用来设定图像的透明度的。如果设为 true 则图像透明， 设为 false 则显示原图。<br /><br />　　本课我们不会使用全部参数。<br /><br />获取图像尺寸<br /><br />　　获取载入的图像尺寸有时很有用，这要用下面两个命令：<br /><br />代码:<br />image:width()<br />image:height()<br /><br />　　实际使用时，用你想获取宽高的图像变量名替换此处的“image”。例如，要获取我们的grass图像的宽度和高度，你可以用：<br /><br />代码:<br />grass:width()<br />grass:height()<br /><br />开始编写程序<br /><br />　　让我们开始编写我们的游戏。第一件要做的就是载入我们的图像。创建一个新文件，输入如下代码：<br /><br />代码:<br />grass = Image.load("grass.png")<br />player = Image.load("player.png")<br />flower = Image.load("flower.png")<br /><br />　　就这样。我们已经把我们的三个图像载入了程序。<br /><br />　　现在我们来用用那些获取图像尺寸的命令。先输入下列代码，然后我会解释的。我还想提醒你，你如果自己手工输入这些代码会比复制粘贴的效果要好。这样你会对这些命令记得更牢。不管怎样，添加如下代码：<br /><br />代码:<br />screenwidth = 480 - player:width()<br />screenheight = 272 - player:width()<br /><br />　　这有什么用吗？我来解释一下它的用途。这部分代码帮助我们让玩家角色到达屏幕边缘时停止，无论是往左或往右（水平方向）。我们知道PSP屏幕尺寸是480，但是如果我们设定屏幕边界是480，我们的角色就会超出屏幕32个像素，因为角色是32像素宽。player:width() 获取玩家图像的宽度，也就是 32 像素。从屏幕的宽度和高度中扣除该值就可以让角色图像在屏幕边缘停止。<br /><br />　　接着我们来创建一个数据表以存储玩家角色的信息。此例程中需要的唯一信息就是玩家在屏幕上的 x 和 y 坐标位。输入如下代码：<br /><br />代码:<br />Player = { } Player[1] = { x = 200, y = 50 }<br /><br />　　这将存储玩家在屏幕上的x、y位置。我们将让玩家从 x 200、y 50 的位置开始。<br /><br />　　现在开始我们的主循环。输入如下代码：<br /><br />代码:<br />while true do<br />pad = Controls.read()<br />screen:clear()<br /><br />　　在下一部分代码中我将引入一个新的循环命令。就是“for”循环。我先举个例子让你了解它的工作方式，无需放在你的代码中。这个例子通过使用一个小循环打印了5个玩家的武器。<br /><br />代码:<br />for a = 1,5 do<br />screen:print(10, 10, Player[a].weapon, green)<br />end<br /><br />　　要使用 for 循环，你要赋予一个临时变量起始值和终止值。<br /><br />　　在上文中我们说 "for a = 1,5 do"，这意味着创建一个循环，其变量 a 的起始值为 1，终止值为 5。你可以理解为“a 等于 1 至 5”。<br /><br />　　然后在循环中我们要打印玩家的武器到屏幕上。<br /><br />　　最后一行是 end 语句，必须使用以终止循环。<br /><br />　　这样，该循环将不断重复直到 a 等于终止值，然后循环终止。第一次循环执行时 a 等于 1。下一次循环时 a 将等于 2，然后是 3，然后是 4，最后是 5。这样就可以快速的将玩家 1 至 5 的武器都打印到屏幕上。当然。实际操作时你需要更改 print 命令的屏幕坐标，不然就都打印到一起去了。但是这展示了该循环的用法。在 for 循环中你也可以根据需要使用 if 语句。<br /><br />　　我们将使用这个命令把我们的grass图像平铺在整个屏幕上。输入下述代码，然后我会解释。当然，如果要做一个带卷轴之类的复杂游戏，使用平铺引擎将是更好的办法，不过目前我们不需要用它。<br /><br />代码:<br />for a = 0, 14 do<br />for b = 0,8 do<br />screen:blit(32 * a, 32 * b, grass)<br />end<br />end<br /><br />　　这里我们在一个 for 循环中嵌套了又一个 for 循环！这将把 grass 图像粘贴到整个屏幕上。横向贴 15 幅图，纵向 9 幅图。请注意，我们设定起始值为 0 而不是 1，这样图像会从屏幕最左边贴起。<br /><br />　　现在让我们再贴一些图像。<br /><br />代码:<br />screen:blit(100,100,flower)<br />screen:blit(300,220,flower)<br />screen:blit(Player[1].x,Player[1].y,player)<br /><br />　　这一段就是简单的贴上两幅 flower 图像，还有 player 的图像。很快，当我们使用移动按键时我们将在每次循环中让玩家的坐标随着按键的按下而改变。使用上述 blit 命令我们的 player 图像将自动粘贴到屏幕的正确区域。<br /><br />　　现在让我们加上那些按键，以检测是否按下了方向键。输入下述代码：<br /><br />代码:<br />if pad:left() and Player[1].x > 0 then<br />Player[1].x = Player[1].x - 2<br />end<br /><br />if pad:right() and Player[1].x < screenwidth then<br />Player[1].x = Player[1].x + 2<br />end<br /><br />if pad:up() and Player[1].y > 0 then<br />Player[1].y = Player[1].y - 2<br />end<br /><br />if pad:down() and Player[1].y < screenheight then<br />Player[1].y = Player[1].y + 2<br />end<br /><br />　　这些代码将检测我们是否按下了“上下左右”键。使用 and 语句同时确保我们没有超出屏幕边界。既然屏幕的最左侧和最顶端的坐标是 0，我们只要检查我们的位置是否大于 0 即可。其他部分我们使用 screenwidth 向右走，screenheight 则用来向下走。这些变量我们之前已创建。如果我们的位置通过了 if 测试，则玩家的 x 或 y 坐标递增或递减 2 点。每次主循环执行都会将 player 图像粘贴到提供给它的新位置。<br /><br />　　最后让我结束循环。使用如下代码：<br /><br />代码:<br />screen.waitVblankStart()<br />screen.flip()<br />end<br /><br />　　保存你的工作，运行吧。使用方向键让角色在屏幕上穿梭。你应该是无法穿越屏幕边缘的。</p>
</div>
</div>

<hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-06 16:24:21</p>
</div>
<div class="col-10">
<p>　　本课我们将学习怎么使用函数。创建一个函数相当于新建一个属于你自己的Lua命令。你可以将经常使用的代码放进函数中，这样你就可以随时调用了。函数放在主循环之外。一般放在代码开头的变量声明附近比较好。<br /><br />　　首先让我们看一下函数是怎么声明的。检查下面代码：<br /><br />代码:<br />function functionName()<br />(函数中要执行的代码。<br />可以使用多行代码。)<br />end<br /><br />　　这就是函数的构成方式，让我们看看下面的示例函数，它将在每次调用时打印一条简单的消息到屏幕。<br /><br />代码:<br />function printMessage()<br />screen:print(100,100, "Functions are fun!")<br />end<br /><br />　　现在，要想在程序中打印这条消息，就必须在要使用的地方调用这个函数。就上例而言使用下述代码就可以调用该函数，将函数的代码执行一次。<br /><br />代码:<br />printMessage()<br /><br />　　这么简单？！呣...恐怕就是这样！使用上述代码将会执行我们先前创建的函数代码。通过调用 printMessage() 就可把 "Functions are fun!" 打印到屏幕上。<br /><br />　　当你开始编写更复杂的程序或游戏时，你将会大量使用函数。在你的主循环中调用函数而不是实际的代码将使你的代码更加整齐易懂。之前我说过函数放在主循环外面，这是对的。但是，从主循环内调用它们是没问题的。<br /><br />　　函数也可以创建来返回一个值。创建函数时加个括号和参数就行。比如说，我们要建个函数将两个数值加起来并把结果返回。首先我们得创建这个函数。看下面：<br /><br />代码:<br />function additUp(a, b)<br />sum = a + b<br />return sum<br />end<br /><br />　　请注意，在括号中我们放了字母 "a" 和 "b"，其实你可以用任何字母或者甚至单词。它们是用于本函数内部的变量，也只存在与本函数中。因为我们打算将两个数相加，所以我们需要两个变量来存储。在你的函数中可以使用任意多个变量，只要你用逗号分开它们。<br /><br />　　然后我们在函数中创建了一个变量叫 "sum"，它将被赋予变量 "a" 和 "b" 相加的数值。等你看到它的调用就会更清楚了。接下来我们使用了一个命令 return，它告诉函数一旦我退出函数将返回一个值给此函数。我们现在要返回的是变量 "sum" 的值。最后，我们 end 了我们的函数。<br /><br />　　现在让我们看看如何使用这个函数，再做一些解释。看如下代码：<br /><br />代码:<br />screen:print(100,100,additUp(5,6), green)<br /><br />　　这将把我们函数的结果打印到屏幕上。请注意，在调用函数时我们使用了实际的数值。此例中我们使用了 5 和 6。就是说将数值 5 赋值给 a，数值 6 赋值给 b。现在在我们先前创建的函数内，任何 a 或 b 被使用的地方，都将被我们实际赋予的数值代替。所以函数中 "sum = a + b" 这句话将被解析为 "sum = 5 + 6"。这将把 11 这个数值赋予 "sum" 变量然后返回给我们的 print 命令，打印到屏幕上。<br /><br />　　如果需要我们也可以将此信息存在一个变量中。这样我们就不必在不需要的时候不得不立即使用它，或者在以后重复使用时不用每次都跑一遍整个函数。请看下面：<br /><br />代码:<br />myTotal = additUp(5,6)<br /><br />　　这句代码就把我们函数的返回值存储在变量 myTotal 里。myTotal 将等于 11。<br /><br />　　让我们看一下上一讲我们编写的程序。代码应该与下面的类似：<br /><br />代码:<br />grass = Image.load("grass.png")<br />player = Image.load("player.png")<br />flower = Image.load("flower.png")<br /><br />screenwidth = 480 - player:width()<br />screenheight = 272 - player:width()<br /><br />Player = { }<br />Player[1] = { x = 200, y = 50 }<br /><br />while true do<br />pad = Controls.read()<br />screen:clear()<br /><br />for a = 0, 14 do<br />for b = 0,8 do<br />screen:blit(32 * a, 32 * b, grass)<br />end<br />end<br /><br />screen:blit(100,100,flower)<br />screen:blit(300,220,flower)<br /><br />screen:blit(Player[1].x,Player[1].y,player)<br /><br />if pad:left() and Player[1].x > 0 then<br />Player[1].x = Player[1].x - 2<br />end<br /><br />if pad:right() and Player[1].x < screenwidth then<br />Player[1].x = Player[1].x + 2<br />end<br /><br />if pad:up() and Player[1].y > 0 then<br />Player[1].y = Player[1].y - 2<br />end<br /><br />if pad:down() and Player[1].y < screenheight then<br />Player[1].y = Player[1].y + 2<br />end<br /><br />screen.waitVblankStart()<br />screen.flip()<br />end<br /><br />　　我们可以创建一些函数，让主循环看上去更干净整齐一些。我们可以将所有的方向键检查放入一个函数，还可以将屏幕绘制的代码放入一个函数。这两个都不需要返回值。看看下面的代码，了解函数的使用：<br /><br />代码:<br />grass = Image.load("grass.png")<br />player = Image.load("player.png")<br />flower = Image.load("flower.png")<br /><br />screenwidth = 480 - player:width()<br />screenheight = 272 - player:width()<br /><br />Player = { }<br />Player[1] = { x = 200, y = 50 }<br /><br />-- Function to check player movements<br />function playerMovement()<br />pad = Controls.read()<br />if pad:left() and Player[1].x > 0 then<br />Player[1].x = Player[1].x - 2<br />end<br /><br />if pad:right() and Player[1].x < screenwidth then<br />Player[1].x = Player[1].x + 2<br />end<br /><br />if pad:up() and Player[1].y > 0 then<br />Player[1].y = Player[1].y - 2<br />end<br /><br />if pad:down() and Player[1].y < screenheight then<br />Player[1].y = Player[1].y + 2<br />end<br />end<br /><br />-- Function to paste images to screen<br />function pasteImages()<br />for a = 0, 14 do<br />for b = 0,8 do<br />screen:blit(32 * a, 32 * b, grass)<br />end<br />end<br /><br />screen:blit(100,100,flower)<br />screen:blit(300,220,flower)<br /><br />screen:blit(Player[1].x,Player[1].y,player)<br />end<br /><br />-- Main Loop<br />while true do<br /><br />screen:clear()<br /><br />pasteImages()<br /><br />playerMovement()<br /><br />screen.waitVblankStart()<br />screen.flip()<br />end<br /><br />　　你看，我们的主循环干净许多了吧。所有复杂的、细节的代码被放到了函数里，而在主循环中我们只需调用它。原先代码中混在循环中的一堆代码都被移走，放到了代码顶端。<br /><br />　　我希望这能帮助学习有关函数使用的知识。以后的教程我们将使用函数了。</p>
</div>
</div>

<hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-06 16:24:59</p>
</div>
<div class="col-10">
<p>　　本课我们将学习如何读取文件和写入文件。这对于制作游戏来说是很有帮助的。你可以调用别的文件中的代码，也可以保存最高分、游戏存档、玩家状态等信息到文件里……<br /><br />　　我们这就开始吧！<br /><br />　　首先，让我们看一个简单的命令：dofile。<br /><br />　　这个命令会读入另一个文件的代码并立即执行。<br /><br />代码:<br />dofile("./test.lua")<br /><br />　　很简单的命令。注意 ./ 是指根目录，不是子目录。如果是子目录，应该这样用：<br /><br />代码:<br />dofile("./files/test.lua")<br /><br />　　那么，如果我们的文件 test.lua 包含下述代码：<br /><br />代码:<br />playerx = 10<br />playery = 20<br />enemyx = 40<br />enemyy = 50<br /><br />　　...则一旦我们用 dofile 调用这个文件，这些变量将立即得到声明。文件不是非得用 lua 后缀，txt 或其他后缀都可以。<br /><br />从文件中读取一行：<br /><br />　　假设你有一个很多行文本的文件，你想从中读取一行，并打印到屏幕上。为此我们可以使用 io.open() 命令打开文件并读取。<br /><br />　　命令的语法是 io.open(filename, mode)。此处我们将使用 r 作为 mode 的值，意指读取（read）模式。<br />作为参考，下面是所有可用模式的列表：<br /><br />引用:<br /><br />    r - 读取模式<br />    w - 写入模式(覆盖现有内容)<br />    a - 附加模式(附加在现有内容之后)<br />    b - 二进制模式<br />    r+ - 读取更新模式(现有数据保留)<br />    w+ - 写入更新模式(现有数据擦除)<br />    a+ - 附加更新模式(现有数据保留，只在文件末尾附加) <br /><br />　　第一件要做的事情就是打开文件并存为一个变量。看下面。<br /><br />代码:<br />file = io.open("testRead.txt", "r")<br /><br />　　现在我们的文件 testRead.txt 已打开并处于读取模式。接着我们使用 read() 命令读取文件中的单行内容存为另一个变量。<br /><br />代码:<br />ourline = file:read()<br /><br />　　这将读取我们的文本文件的第一行。下一次我们使用 read() 命令它将读取第二行。再下一次它会读取第三行，依此类推。<br /><br />　　请注意，此命令前的 file 是我们之前打开文件并保存的变量名，你可以使用任何其他名字。file.read() 还可以使用下列任一个参数，只要用引号括起来放入括号里就可以。<br /><br />引用:<br /><br />    *n - 读取一个数字并返回它。例：file.read("*n")<br />    *a - 从当前位置读取整个文件。例：file.read("*a")<br />    *l - (默认) - 读取下一行，在文件尾 (EOF) 处返回 nil。例：file.read("*l")<br />    number - 返回一个指定字符个数的字符串，或在 EOF 时返回 nil。例：file.read(5) <br /><br />　　既然我们已经读取到所要的那一行，我们需要关闭打开的文件，像这样：<br /><br />代码:<br />file:close()<br /><br />　　现在要打印我们的文件至屏幕我们只要这么做：<br /><br />代码:<br />screen:print(10,10,ourline,white)<br /><br />读取所有行<br /><br />　　要读取一个文件的所有行，你可以在一个 for 语句中使用上述技巧。请看下述代码：<br /><br />代码:<br />y = 10<br /><br />file = io.open("testRead.txt","r")<br /><br />for line in file:lines() do<br />y = y + 10<br />screen:print(100,y,line,white)<br />end<br /><br />file:close()<br /><br />　　这个代码设置了一个起始值 y 用于打印，这样它可以在屏幕不同的纵坐标打印每一行。照例，先打开文件。然后是 for 语句，这句代码是说文件的行数有多少下面的代码就执行几次。我们的 y 坐标则每次循环加上 10 以便打印命令可以打印下一行。<br /><br />写入文件（覆盖）<br /><br />　　写入文件的方式大致相同。下面的代码将覆盖任何先前写入文件的内容：<br /><br />代码:<br />file = io.open("testRead.txt","w")<br />file:write("hello")<br />file:close()<br /><br />　　注意，我们这次使用了 w 模式，而不是 r 模式，因为我们是要写入而不是读取。我们用 file:write() 写入括号里作为参数的、用引号括起来的文本。你也可以用变量替代。如果你使用变量就不要用引号，请看下例：<br /><br />代码:<br />file = io.open("testRead.txt","w")<br />myText = "Hello"<br />file:write(myText)<br />file:close()<br /><br />写入文件（附加）<br /><br />　　你可以使用附加模式，这样就可以在写入文件时将新内容附加在已有文本末尾，而不是删除原来的。做法与上面基本相同，除了模式换成“附加”之外。请看代码：<br /><br />代码:<br />file = io.open("testRead.txt","a")<br />myText = "<br />Hello"<br />file:write(myText)<br />file:close()<br /><br />　　注意到另一个区别没？在 myText 变量里我们为字符串添加了 <br /> 。这个命令代表换行，这样写入的文本将从下一行开始。虽然在你的文件中可能显示为同一行只是中间隔了一个方块，但是技术上它是新的一行。在 C/C++ 语言中也是这么用的。<br /><br />　　将你所学的知识用在自己的小程序上吧。<br /><br />　　我们的下一讲将讨论音频的处理，也会使用我们此处所学的读写文件的命令做一个小程序。</p>
</div>
</div>

<hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-06 16:27:26</p>
</div>
<div class="col-10">
<p>　　现在该是时候给我们的项目加点响声了。任何游戏都需要声音，这一讲我们就来学学如何在Luaplayer中发声。开始上课!<br /><br />　　luaplayer 可以播放如下音乐格式*：UNI, IT, XM, S3M, MOD, MTM, STM, DSM, MED, FAR, ULT 或 669，WAV 文件可用作声音。MIDI可以先转换为上述格式再使用，比如 Modplug Tracker 就可以转。请记住 luaplayer 不支持 mp3 文件*。在学习了一些音频命令之后我们将结合之前的成果创建一个小程序。<br /><br />　　*译者注：此说法已过时，目前luaplayer已支持mp3,ogg，aa3，oma，omg，详见HM版相关函数。但是由于luaplayer目的在于编游戏，所以对mp3播放的支持程度不高。<br /><br />　　先来看第一个命令，此命令将播放一个音乐文件。<br /><br />代码:<br />Music.playFile( string file, bool loop )<br /><br />　　此处的“string file”是指你的音乐文件名，例如“song.xm”。“bool loop”处放置“true”或者“false”。设“true”则一直循环播放该音乐，“false”则只播一遍。下面是个放歌的示例：<br /><br />代码:<br />Music.playFile("mysong.mod", true)<br /><br />　　接下来看看这个命令。它们是在开始播放音乐之后使用的：<br /><br />代码:<br />Music.pause()<br />Music.stop()<br />Music.resume()<br /><br />　　这些命令不用解释你也能看懂。<br />　　Music.pause() 将暂停歌曲播放。<br />　　Music.stop() 将停止歌曲播放。<br />　　Music.resume() 将恢复播放被暂停的歌曲。<br /><br />　　还有一个命令是用来侦测一首歌是否正在播放。这将返回 true 或 false。看一下：<br /><br />代码:<br />Music.playing()<br /><br />　　假如说我们想侦测我们的歌曲是否在播放，如果是则打印一条消息到屏幕。我们可以这样做：<br /><br />代码:<br />if Music.playing() == true then<br />screen:print(10,10,"Music is playing",white)<br />end<br /><br />　　还有一个命令是用来设置音乐文件的音量的。只要在括号中填入一个数值，范围在 0 至 128 之间。下面是命令格式：<br /><br />代码:<br />Music.volume(Number)<br /><br />　　现在让我们学学用于音效的声音文件，尤其是 wav 文件。这和播放音乐文件有些区别。下面是如何载入一个声音：<br /><br />代码:<br />bonkSound = Sound.load("bonk.wav",false)<br /><br />　　wav 文件作为一个变量被载入，稍后我们就可以用这个变量来指称该声音。此处我们设“false”是以防循环播放。记住设为“true”将循环播放，如果你的确是这么想的话。<br /><br />　　关于 WAV 文件的一个要点是，在 luaplayer 中只能使用单声道的，立体声的不行。你可以通过右键点击文件查看其属性的摘要页来确认这一点。<br /><br />　　现在让我们来再学一些命令。下个命令是播放该文件。使用你载入声音时设的变量名。如下：<br /><br />代码:<br />bonkSound:play()<br /><br />　　但是我不建议你这样播放声音文件。这会导致一个常见错误，类似“loop ingettable(无法取得循环)”之类消息。下面是我播放声音文件的方法。不同之处就是用另一个变量取代 bonkSound。<br /><br />代码:<br />local sound = bonkSound<br />voice = sound:play()<br />--要停止声音使用：<br />voice:stop()<br /><br />　　还有一个命令与音乐文件的命令类似，侦测声音是否正在播放。命令如下：<br /><br />代码:<br />voice:playing()<br /><br />　　还有一些声音和音乐方面的命令等待你去探究，但是这些已足够你使用声音和音乐了。<br /><br />　　现在我们开始做一个小玩意儿。我们将以一个菜单屏幕为起始，用来选择蓝色还是黑色背景。按下 X 时程序会往下执行，而背景色已按照我们的选择设好。此处我们的程序将显示其已被执行多少次。怎么做？嗯，就是每次在菜单屏幕按下 X 时程序就打开一个文件（我们稍后会创建），然后写一个数字进文件。程序也会从该文件中读取该数字并保存在一个变量中。如果你完全退出程序然后再返回，它仍然能显示被执行了多少次，因为这个数据已存在一个文件里了。那么，让我们忙起来吧。<br /><br />　　首先，我想要你用notepad或任何其他编辑器创建一个普通的txt文件。在该文本文件中输入数字 0。保存为 counter.txt。就是一个普通的文本文件。<br /><br />　　然后开始编写我们的 lua 文件。先创建一些要用到的色彩对象：<br /><br />代码:<br />white = Color.new(255,255,255)<br />blue = Color.new(0,0,255)<br />black = Color.new(0,0,0)<br /><br />　　接着是一些变量。<br /><br />代码:<br />oldpad = Controls.read()<br />startcolor = black<br />gamestate = "menu"<br /><br />　　oldpad 将储存我们上一次按下的按键。<br />　　startcolor 存储我们稍后将在程序第二部分使用的颜色。我们以 black 开始。<br />　　gamestate 则是用来查看该使用哪个函数。我们将创建两个函数。一个是显示菜单的，另一个执行程序余下的工作。既然我们从菜单开始，该变量的起始值就如此设置。<br /><br />　　下一部分就要处理声音了！首先，请下载两个小小的 WAV 文件，放在程序所在目录下。<br /><br />　　现在让我们在程序中载入这些 wav 文件。我们不想让它们循环，所以使用 false。<br /><br />代码:<br />menusound = Sound.load("beep.wav",false)<br />goodbye = Sound.load("goodbye.wav",false)<br /><br />　　够简单吧！还记得上一讲的那些文件命令吗？我们来次回顾吧。此处我们将打开我们之前创建的 counter.txt 文件，并从中读取数值存入变量 counter 中。<br /><br />代码:<br />file = io.open("counter.txt", "r")<br />counter = file:read("*n")<br />file:close()<br /><br />　　请注意我们使用了"*n"以读入一个数字。<br /><br />　　接着我们将创建一个数据表，用于我们的起始屏幕选择器。这会包含一个我们创建来用作选择器的图像，以及它的 x 和 y 坐标值。数据表下一行的命令则将我们的选择器图像以蓝色清空。代码如下：<br /><br />代码:<br />selector = { image = Image.createEmpty(145,15), x = 147,y = 77 }<br />selector.image:clear(blue)<br /><br />　　现在我们建一个称为 drawMenu() 的函数，执行菜单所有的必要任务。下面是起始行：<br /><br />代码:<br />function drawMenu()<br /><br />　　我们将把此函数用作一个循环函数，所以每次循环我们先清屏然后读取按键的输入。代码如下：<br /><br />代码:<br />screen:clear()<br />pad = Controls.read()<br /><br />　　接下来我们将把我们的选择器绘制(blit)到屏幕上，并打印两行字。代码如下：<br /><br />代码:<br />screen:blit(selector.x,selector.y,selector.image)<br />screen:print(150,80,"Start Game (Black)",white)<br />screen:print(150,100,"Start Game (Blue)",white)<br /><br />　　请注意我们是怎么使用数据表的值来绘制选择器到屏幕上的。这个选择器图像将会上下移动以高亮显示被选择的菜单项。要确保在打印文字之前绘制，否则图像将覆盖文字。<br /><br />　　打印的两行字则是我们给玩家的选项。要么以黑色屏幕开始游戏，要么是蓝色的屏幕。<br /><br />　　在函数的下一部分将检测按键是否按下。先做上键的部分吧。<br /><br />代码:<br />if pad:up() and oldpad:up() ~= pad:up() then<br />selector.y = 77<br />startcolor = black<br />local sound = menusound<br />voice = sound:play()<br />end<br /><br />　　第一行是说如果上键被按下并且不是最后被按下的按钮则.....<br /><br />　　第二行将 selector 的 y 值设置为 77。这是为了在文本周围贴上图像以便看起来像是被选择的。<br />然后设置 startcolor 为 black。<br /><br />　　接着使用我之前建议的方法播放 menusound 这个 wav 文件。<br /><br />　　现在处理下键。代码与上面很相似，除了图像向下一点，颜色改为蓝色以外。代码如下：<br /><br />代码:<br />if pad:down() and oldpad:down() ~= pad:down() then<br />selector.y = 97<br />startcolor = blue<br />local sound = menusound<br />voice = sound:play()<br />end<br /><br />　　现在来处理 X 按钮。<br /><br />代码:<br />if pad:cross() and oldpad:cross() ~= pad:cross() then<br />gamestate = "game"<br />counter = counter + 1<br />file = io.open("counter.txt","w")<br />file:write(counter)<br />file:close()<br />end<br />end<br /><br />　　此处我们将 gamestate 设为“game”以便菜单的代码不再执行（在我们编写了后面的代码之后）。我们以 1 为基数递增 counter 变量。然后打开 txt 文件，写入 counter 的新值，替换文件里的旧值。不要忘了关闭文件。<br /><br />　　注意，多出来的那个 end 是用来终结函数的。这个函数已完成了！<br /><br />　　我们下一个函数将执行离开菜单后的游戏代码。这个函数相当小巧简单，全部代码如下：<br /><br />代码:<br />function playGame()<br />screen:clear(startcolor)<br />pad = Controls.read()<br />screen:print(100,100,"This program has been executed " .. counter .. " times.",white)<br />screen:print(100,110,"Press Start to exit to Menu",white)<br /><br />if pad:start() then<br />gamestate = "menu"<br />local sound = goodbye<br />voice = sound:play()<br />end<br />end<br /><br />　　在此函数中，请注意我们使用了在菜单中通过 startcolor 变量选择的颜色清屏。打印了两个消息，检查了 start 按键的按下。按下 start 键将把 gamestate 设回 menu 并播放一个 wav 文件。<br /><br />　　接下来开始我们的程序主循环。由于使用了函数，此处很简短。在循环中我们将检查游戏的状态并执行该状态的函数。代码如下！<br /><br />代码:<br />while true do<br /><br />if gamestate == "menu" then<br />drawMenu()<br />end<br /><br />if gamestate == "game" then<br />playGame()<br />end<br /><br />screen.flip()<br />oldpad = pad<br />end<br /><br />　　...接下来... Oh yeah！已经完成啦！运行试试看吧。</p>
</div>
</div>

<hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-06 16:28:03</p>
</div>
<div class="col-10">
<p>　　本课我们将学习在程序中如何使用毫秒定时器。定时器可以在程序中派很多用处。通过定时器你可以使某些代码仅在一个正确的时间段内执行。<br /><br />　　下面这个小型的PSP程序将教您使用定时器，并显示讯息在屏幕上。显示的信息内容取决于计时器的时间。<br /><br />　　首先，让我们创建一个白色对象。<br /><br />代码:<br />white = Color.new(255,255,255)<br /><br />　　为了创建一个定时器，我们使用命令 Timer.new()。 我们将此定时器存为一个变量。下面让我们创建一个定时器。<br /><br />代码:<br /><br />counter = Timer.new()<br /><br />　　要启动或停止一个定时器请使用命令 timername:start() 和 timername:stop()。我们想在程序开始启动我们的定时器，所以加上下面代码：<br /><br />代码:<br />counter:start()<br /><br />　　请注意我们在命令中使用了刚才创建的定时器名字。 下一步，我们来创建我们程序的主循环，并添加每次循环清屏的代码。如下：<br /><br />代码:<br />while true do<br />screen:clear()<br /><br />　　现在，在我们的程序中将需要与定时器的计时步伐保持一致。我们将利用定时器的当前时间显示信息到屏幕上。我们可以通过命令 countername:time() 得到定时器的当前时间。添加如下代码：<br /><br />代码:<br />currentTime = counter:time()<br /><br />　　这会把定时器的当前时间保存到变量 currentTime 中。下面我们加入一些代码，在每次循环时将定时器的当前时间打印到屏幕上。代码如下：<br /><br />代码:<br />screen:print(10,10,"Counter Time: " .. currentTime,white)<br /><br />　　现在，我们将使用一些 if 语句来判断我们的定时器是否在某个时间，若是则显示一则消息。先来加上第一项：<br /><br />代码:<br />if currentTime < 1000 then<br />screen:print(100,100,"Less than 1000",white)<br />end<br /><br />　　这段代码是检查定时器的时间是否小于1000。如果是，则“Less than 1000”将打印到屏幕上。现在，让我们再加入一项。<br /><br />代码:<br />if currentTime > 1000 and currentTime < 2000 then<br />screen:print(100,100,"Greater than 1000",white)<br />end<br /><br />　　这将检查定时器的时间是否比1000大，但小于2000。如果是，则“Greater than 1000”将被打印。最后的 if 语句将在时间超过2000时把我们的定时器复位回零。 我们可以使用 timername:reset(number) 命令重置定时器。<br /><br />　　括号内的数值是定时器将被设回的起始时间。复位定时器也将停止定时器，所以我们还要重新启动它。代码如下：<br /><br />代码:<br />if currentTime > 2000 then<br />counter:reset(0)<br />counter:start()<br />end<br /><br />　　通过此代码，如果定时器时间超过2000，我们的定时器将复位回零并重新开始。最后，让我们结束我们的主循环。<br /><br />代码:<br />screen.waitVblankStart()<br />screen.flip() end<br /><br />　　保存并运行你的程序，看看动起来的定时器吧。</p>
</div>
</div>

<hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-06 16:28:37</p>
</div>
<div class="col-10">
<p>　　本课我们讲解如何在 lua 中制作一些简单的碰撞。本方法使用盒式碰撞，没有达到像素级精度。因为这是你的第一次碰撞尝试，所以简单一点好。<br /><br />　　我们将要做的这个小演示将使用一个可移动的玩家角色。屏幕上还有三个实施了碰撞效果的方块。玩家将无法穿过这些方块。<br /><br />　　首先我们创建两个要用的色彩。一个用于玩家，一个用于我们的方块。<br /><br />代码:<br />green=Color.new(0,255,0)<br />white = Color.new(255,255,255)<br /><br />　　接着创建玩家和方块要用的图像。先创建空的 32x32 的方块，然后用我们刚刚创建的颜色填充它们。<br /><br />代码:<br />player = Image.createEmpty(32,32)<br />player:clear(white)<br />block = Image.createEmpty(32,32)<br />block:clear(green)<br /><br />　　现在我们需要创建一个数列来存放我们的玩家信息。本演示中就是简单的保存玩家的 x 和 y 坐标位置。<br /><br />代码:<br />Player = { x = 30, y = 100 }<br /><br />　　接下来我们要定义两个变量，存储我们玩家图像的高和宽。这些值将用于我们的碰撞函数中。记住我们刚才是以 32x32 创建图像的，所以那就是我们要用的值。<br /><br />代码:<br />playerHeight = 32<br />playerWidth = 32<br /><br />　　然后，为我们的三个方块也创建一个数列来存储信息。自然，我们要存储每个方块在屏幕上所处的 x,y 值，还有每个方块的宽度与高度。我们使用 width() 和 height() 命令来自动从我们刚才创建的方块图像中获取这些值。代码如下：<br /><br />代码:<br />Block = {}<br />Block[1] = { x = 100, y = 80, height = block:height(), width = block:width() }<br />Block[2] = { x = 300, y = 30, height = block:height(), width = block:width() }<br />Block[3] = { x = 200, y = 58, height = block:height(), width = block:width() }<br /><br />　　现在让我们写一个函数让玩家动起来。每次循环都会调用这个函数以检查移动。如果你认真学了前面的课程，应该不难理解下面的代码：<br /><br />代码:<br />function movePlayer()<br />pad = Controls.read()<br />if pad:left() then<br />Player.x = Player.x - 1<br />end<br />if pad:right() then<br />Player.x = Player.x + 1<br />end<br />if pad:up() then<br />Player.y = Player.y - 1<br />end<br />if pad:down() then<br />Player.y = Player.y + 1<br />end<br />end<br /><br />　　...终于到好玩的地方了。该是时候创建一个函数来检查碰撞是否产生了。这个函数将使得我们能对游戏中任何一个对象检测碰撞，只要在循环中为该对象调用该函数。先看一下整个函数，然后我们来分析一下。<br /><br />代码:<br />function collisionCheck(object)<br />if (Player.x + playerWidth > object.x) and (Player.x < object.x + object.width) and (Player.y + playerHeight > object.y) and (Player.y < object.y + object.height) then<br />Player.x = oldx<br />Player.y = oldy<br />end<br />end<br /><br />　　看一下第一行：function collisionCheck(object)<br /><br />　　这是创建一个名为 collisionCheck 的函数。注意括号里的词 object，简单的说这就是一个“替代”变量。当我们稍后实际使用这个函数时需要用我们想要测试碰撞的对象名替换这个词。再往下看你会发现 object 这个词出现了很多次。一旦该函数执行，所有的 object 都会被替换为我们测试的实际对象名。<br /><br />　　有没有觉得第二行很华丽？！<br /><br />　　这一行的 if 语句检测了好几个条件。请注意我把每一块条件都放进了括号里，这样如此长的代码会容易阅读一些。<br /><br />　　首先是检测是否 (Player.x + playerWidth > object.x)。一个图像的 x 值就是指该图像的左上角顶端的横坐标。碰撞的关键就是检测两个图像是否彼此有重叠，如果是则让他们停止重叠。那么为什么要在玩家的 x 值上再加上玩家的宽度呢？很简单，因为如果我们只检测玩家的 x 值，那么只有玩家图像的左上角顶端重叠了才会检测到碰撞。如果我们向右移动，而有一个方块挡在路上，我们需要碰撞在玩家图像的右侧边缘发生。玩家的 x 值加上其宽度就是该图像的右上角顶端的值。<br /><br />　　简单来说，我们要做的就是在图像周围创建一个要求碰撞的盒型区域。一旦移动该盒型区域即为发生碰撞。<br /><br />　　我画了几张图让你对这行代码有形象化的理解。蓝色方盒是个静止的方块，而那个绿色方盒就是玩家。黑线表明碰撞发生的地方。<br /><br />　　到目前为止我们只是检测了玩家的右侧是否越过了其他物体的 x 坐标。<br /><br />　　正如你看到的，现在我们的玩家处于碰撞区域中……但是我们还有更多的检测要做。下一个条件是 (Player.x < object.x + object.width)。<br />这个代码用于向左移动碰上物体图像右侧的时候。就是前一条件的反例而已。物体对象的 x 值加上它的宽度就是该物体的右侧。现在让我们看看前两个检查条件下的碰撞区域。<br /><br />　　目前为止我们仍然处于碰撞区域。在设定了前两个条件之后，必须在这两条黑线之间碰撞才会发生。<br /><br />　　下一个条件是 (Player.y + playerHeight > object.y)。<br /><br />　　这是用于向下移动的时候。玩家的 y 坐标加上玩家的高度就是玩家图像的底端。如果该值大于其他物体的 y 坐标，则碰撞发生。让我们看看三个条件下的碰撞区域。<br /><br />　　现在你会发现物体方块的上方已不再是碰撞区域，而玩家图像的底端必须大于物体方块图像的顶端才能使碰撞发生。<br /><br />　　最后一个检查条件是 (Player.y < object.y + object.height)。<br /><br />　　这部分代码用于检查向上移动。如果玩家的 y 坐标小于物体的底端（y 坐标加高度）则碰撞发生。这次我们使用“小于”是因为在屏幕上向上移动时 y 值是递减的。现在看看碰撞情况。<br /><br />　　现在物体方块的底部以下也不是碰撞区域了。唯一会发生碰撞的地方就是方块所占据的区域。通过 if 语句的四个条件我们将方块所占区域包围了起来。<br /><br />　　接着我们必须设定一旦进入该区域会发生什么，所以我们将玩家的 x 和 y 值设为 oldx 和 oldy。<br /><br />　　此时我们尚未定义 oldx 和 oldy 的值。这是我们在主循环中要做的第一件事。这些值在每次循环开始时会被玩家当前的 x 和 y 值设定。如果我们的函数判断玩家处于碰撞区域则将玩家的位置设回上一次的位置，也就是 oldx 和 oldy 存储的值。这样我们就永远无法走进物体方块中了。函数在此结束。希望我上述的详细解析能帮到你理解这个函数。<br /><br />　　最后就是我们的主循环。学到这你应该对下面的代码不难理解了。<br /><br />代码:<br />while true do<br /><br />-- store player's position at beginning of each loop<br />oldx = Player.x<br />oldy = Player.y<br />screen:clear()<br /><br />movePlayer()<br /><br />--check collision for each block<br />collisionCheck(Block[1])<br />collisionCheck(Block[2])<br />collisionCheck(Block[3])<br /><br />--paste player to screen<br />screen:blit(Player.x,Player.y,player)<br /><br />--paste all 3 blocks to screen<br />for a = 1,3 do<br />screen:blit(Block[a].x,Block[a].y,block)<br />end<br /><br />screen.waitVblankStart()<br />screen.flip()<br />end</p>
</div>
</div>


            
            <div class="row">
                <nav aria-label="Page navigation example">
                    <ul class="pagination justify-content-center">
                    <!--<li class="page-item disabled">
                        <a class="page-link">Previous</a>
                    </li>
                    <li class="page-item"><a class="page-link" href="#">1</a></li>
                    <li class="page-item"><a class="page-link" href="#">2</a></li>
                    <li class="page-item"><a class="page-link" href="#">3</a></li>
                    <li class="page-item">
                        <a class="page-link" href="#">Next</a>
                    </li>
                        -->
                        <li class="page-item active">
<a class="page-link" href="post17015_1.html">1</a>
</li>


                    </ul>
                </nav>
            </div>
        </div>


        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    </body>
</html>

