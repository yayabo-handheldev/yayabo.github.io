
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>PSPGU文档翻译</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    </head>

    <body style="margin-top:1.618%">
        <div class="container">
            <div class="row">
                <div class="jumbotron">
                    <h1 class="display-5">PSPGU文档翻译</h1>
                </div>
                <br />
                <nav class="nav">
                    <a class="nav-link active" aria-current="page" href="index_17.html">返回</a>
                </nav>
            </div>

            <hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-17 09:36:38</p>
</div>
<div class="col-10">
<p>摘自：pspchina<br />作者：sd3655633<br /><br />PSP使用类似D3D的可变顶点格式(FVF),以一下顺序定义:<br />1. 纹理坐标,可以用到的标志:<br />n GU_TEXTURE_32BITF:32位浮点类型;<br />n GU_TEXTURE_16BIT:16位整型;<br />n GU_TEXTURE_8BIT:8位整型;<br />2. 权重,用于骨骼动画:<br />n GU_NORMAL_8BIT – 8位法向量<br />n GU_NORMAL_16BIT – 16位法向量<br />n GU_NORMAL_32BITF – 32位法向量,浮点类型<br /><br />3. 顶点颜色(漫反射颜色,之前是否有境面高光), 可以用到的标志:<br />n GU_COLOR_8888: 32位,R_8,G_8,B_8,A_8;<br />n GU_COLOR_4444: 16位,R_4,G_4,B_4,A_4;<br />n GU_COLOR_5650: 16位,R_5,G_6,B_5,A_0;<br />n GU_COLOR_5551: 16位,R_5,G_5,B_5,A_1;<br /><br />4. 法向量,可以用到的标志:<br />n GU_NORMAL_32BITF:32位浮点类型;<br />n GU_NORMAL_16BIT:16位整型;<br />n GU_NORMAL_8BIT:8位整型;<br /><br />5. 顶点向量,可以用到的标志:<br />n GU_VERTEX_32BITF(同上);<br />n GU_VERTEX_16BIT;<br />n GU_VERTEX_8BIT;<br /><br />顶点定义必须安以下顺序:<br />[for vertices(1-8)] [texture uv] [weights (0-8)] [color] [normal] [vertex] [/for]<br />注意:这是在文档中给出的定义顺序,在samplesguskinning这个例子中定义顺序又有不同,在samplegumorphskin中也是同样的,在按照文档的顺序来定义顶点在渲染后出了错误的结果,所以,正确的顺序应该如下:<br />[for vertices(1-8)] [weights (0-8)] [texture uv] [color] [normal] [vertex] [/for]<br />[for vertices(1-8)][/for]是告诉GE,一个结构中有几个顶点,通过GU_VERTICES(n)标志来设置.<br /><br />以下为显示函数:<br /><br />int sceGuDisplay(int state)<br />打开或者关闭显示<br />可用的参数:<br />n GU_TRUE (1) – 打开显示<br />n GU_FALSE (0) – 关闭显示<br /><br />返回:<br />返回这次调用之间的状态<br /><br />void sceGuInit(void)<br />初始化GU System.<br />这个函数必须比其他显示函数先调用,否则一些错误状态将被使用<br /><br />void sceGuTerm(void)<br />关闭GU System<br />当不在需要GU的时候调用<br /><br />void sceGuStart(int cid,void* list)<br />开始填充一个显示上下文<br />参数:<br />n cid 上下文类型<br />n list 显示列表(16字节对其)<br /><br />void sceGuFinish(void)<br />结束填充当前的上下文,并回到上一级显示上下文<br /><br />void sceGuDepthBuffer(void* zbp,int zbw)<br />设置深度缓存参数.<br />参数:<br />n zbp 指向深度缓存<br />n zbw 深度缓存宽度(内存对其)<br />注意:z-buffer始终是16bit的<br /><br />void sceGuDisplay(int width,int height,void* dispbp,int dispbw)<br />设置显示缓存的参数<br />参数:<br />n width 显示缓存的宽,以象素为单位<br />n height 显示缓存的高,以象素为单位<br />n dispbp 指向显示缓存<br />n dispbw 显示缓存的宽(内存对其)<br /><br />void sceGuDrawBuffer(int psm,void* fbp,int fbw)<br />设置绘制缓存参数<br />参数:<br />n psm 显示缓存的格式<br />u GU_PSM_5650<br />u GU_PSM_5551<br />u GU_PSM_4444<br />u GU_PSM_8888<br /><br />n fbp 指向显示缓存<br />n fbw 显示缓存的宽度<br />主意:SceGuDrawBuffer和 sceGuDisplay会形成一个换页链,DisplayBuffer中的格式就是DrawBuffer中的格式,而DisplayBuffer的长宽就是DrawBuffer的长宽,DisplayBuffer和DrawBuffer通过sceGuSwapBuffers()来进行交换<br /><br />void sceGuDepthFunc(int function)<br />选择一个深度测试函数<br />参数:<br />n function 一个将要被用到的深度测试函数<br />u GU_NEVER – 测试总是失败<br />u GU_ALWAYS – 测试总是成功<br />u GU_EQUAL – 相等则通过<br />u GU_NOTEQUAL – 不等则通过<br />u GU_LESS – 小于则通过<br />u GU_LEQUAL – 小于等于则通过<br />u GU_GREATER – 大于则通过<br />u GU_GEQUAL – 大于等于则通过<br /><br />void sceGuDepthMask(int mask)<br />设置Z –buffer是否可写<br />参数:mask GU_TRUE 不可写<br />GU_FALSE 可写<br /><br />void sceGuDepthRange(int near,int far)<br />设置深度缓存的范围<br />参数:<br />n near 近端<br />n far 远端<br />注意:z-buffer始终是16bit的,即范围在0xFFFF-0x0之间<br />例子:sceGuDepthRange(0xc350,0x2710);<br /><br />void sceGuFog(float near,float far, unsigned int color)<br />设置雾参数<br />参数:<br />n near,far雾的范围<br />n color 雾的颜色<br /><br />void sceGuSendCommandf (int cmd, float argument)<br />向GE发送命令,参数必须是24-bit以上浮点类型<br />参数:<br />n cmd 将要发送的命令<br />n argument 命令的参数<br /><br />void sceGuSendCommandi(int cmd, int argument)<br />向GE发送命令,参数的低24-bit将会被传送<br />参数:<br />n cmd将要发送的命令<br />n argument命令的参数<br /><br />void * sceGuGetMemory (int size)<br />从当前的显示列表中分配一段内存<br />参数:<br />n size 将要分配的内存大小,以字节为单位<br />返回:指向分配的内存地址<br /><br />void sceGuCallList(const void * list)<br />调用先前产生的显示列表<br />参数:<br />n list 被调用的显示列表<br />返回:无<br /><br />void sceGuCallMode (int mode)<br />设置使用信号模式还是堆栈模式<br />参数<br />n mode – GU_TRUE 信号模式,GU_FALSE 一般模式(堆栈)<br /><br />int sceGuCheckList(void)<br />检查当前的display-list的大小<br />返回:当前display-list的长度<br /><br />void sceGuSendList(int mode, const void* list, PspGeContext* context)<br />发送链表到GE<br />可用到的方式:<br />n GU_TAIL – 队列最后,安顺序执行<br />n GU_HEAD – 队列开始,会尽可能快的被执行<br />参数:<br />n mode - 链表在队列中的位置,是开始还是在最后<br />n list - 将要发送的链表<br />n context - GE上下文<br />返回:无<br /><br /><br /><br />void* sceGuSwapBuffers(void)<br />翻页,交换DrawBuffer和DisplayBuffer,仅交互指针<br />参数:<br />n 无<br />返回:新的DrawBuffer的指针<br /><br />int sceGuSync(int mode,int a1)<br />等到display-list执行完毕后返回<br />参数:<br />n mode – 未知,设置为0<br />n a1 – 未知,设置为0<br />返回: Unknown at this time<br />例子:<br />sceGuSync(0,0);<br /><br />void sceGuDrawArray(int prim,int vtype,int count,<br />const void* indices,const void* vertices)<br />根据原始顶点作图<br />可用到的原始类型:<br />n GU_POINTS – 单一点,每个点一个顶点<br />n GU_LINES – 单一线段,每个线段两个顶点<br />n GU_LINE_STRIP - 连续线段,第一个线段两个顶点,以后的线段在前一个线段的末端加一个顶点连成新的线段<br />n GU_TRIANGLES – 单一三角形,三个顶点<br />n GU_TRIANGLES_STRIP – 三角形带,头一个三角形三个顶点,以后每个三角形追加一个顶点<br />n GU_TRIANGLE_FAN – 扇面三角形, ,头一个三角形三个顶点,以后每个三角形追加一个顶点<br />n GU_SPRITES – 精灵(矩形),每个两个顶点<br />顶点类型描述将自定义的顶点格式包含那些内容给GE.下面的标志可以通过OR操作组合在一起来描述一个自定义的顶点格式:<br /><br /><br />GU_TEXTURE_8BIT – 8位纹理坐标<br />GU_TEXTURE _16BIT – 16位纹理坐标<br />GU_TEXTURE_32BITF - 32位纹理坐标,浮点类型<br />GU_COLOR_5650 – 16 位颜色值(R5G6B5A0)<br />GU_COLOR_5551 – 16位颜色值(R5G5B5A1)<br />GU_COLOR_4444 – 16位颜色值(R4G4B4A4)<br />GU_COLOR_8888 – 32位颜色值(R8G8B8A8)<br />GU_NORMAL_8BIT – 8位法向量<br />GU_NORMAL_16BIT – 16位法向量<br />GU_NORMAL_32BITF – 32位法向量,浮点类型<br />GU_VERTEX_8BIT – 8位顶点位置向量<br />GU_VERTEX_16BIT – 16位顶点位置向量<br />GU_VERTEX_32BITF - 32位顶点位置向量 浮点类型<br />GU_WEIGHT_8BIT – 8位权重<br />GU_WEIGHT_16BIT – 16位权重<br />GU_WEIGHT_32BITF – 32位权重,浮点类型<br />GU_INDEX_8BIT – 8位顶点索引<br />GU_INDEX_16BIT – 16位顶点索引<br />GU_WEIGHTS(n) – 权重数量(1-8)<br />GU_VERTICES(n) – 一个自定义顶点格式中的顶点数量<br />GU_TRANSFORM_2D – 直接光栅化<br />GU_TRANSFORM_3D – 光栅化前变换<br /><br /><br /><br /><br /><br /><br /><br />注意:每个顶点必须32位对齐,如果不足要补齐32的倍数<br />顶点格式顺序: [for vertices(1-8)] [texture uv] [weights (0-8)] [color] [normal] [vertex] [/for]<br />注意开头关于格式部分<br />例子:渲染400个三角形,使用浮点纹理坐标(GU_TEXTURE_32BITF)和浮点顶点向量sceGuDrawArray (GU_TRIANGLES,GU_TEXTURE_32BITF | GU_VERTEX_32BITF,400*3,0,vertices);<br />参数:<br />n prim – 原始数据的类型<br />n vtype – 类型描述<br />n count – 顶点数量<br />n indices – 索引列表<br />n vertices – 顶点列表<br /><br />void sceGuBeginObject(int type,int ai,const void* indices,const void* vertices);<br />Begin conditional rendering of object.<br />If no vertices passed into this function are inside the scissor region, it will skip rendering the object. There can be up to 32 levels of conditional testing, and all levels HAVE to be terminated by sceGuEndObject().<br />Example: test a boundingbox against the frustum, and if visible, render object<br />sceGuBeginObject(GU_VERTEX_32BITF,8,0,boundingBox);<br />sceGuDrawArray(GU_TRIANGLES,GU_TEXTURE_32BITF|GU_VERTEX_32BITF,vertexCount,0,vertices);<br />sceGuEndObject();<br />参数:<br />n vtype - Vertex type to process<br />n count - Number of vertices to test<br />n indices - Optional list to an index-list<br />n vertices - Pointer to a vertex-list<br /><br />void sceGuEndObject(void);<br />End conditional rendering of object<br /><br />void sceGuSetStatus(int state,<br />int status)<br />设置相关渲染状态,相关状态参考sceGuEnable;<br />参数:<br />n state – 那个状态将要改变<br />n status – disable 还是enable<br /><br />int sceGuGetStatus(int state)<br />取得指定渲染状态是disabled 还是enabled, 相关状态参考sceGuEnable;<br />参数:<br />n state – 指定要检查的渲染状态<br />返回:指定渲染状态是enabled,还是disabled;<br /><br />void sceGuSetAllStatus(int status)<br />设置所有的22个可用的渲染状态, 相关状态参考sceGuEnable;<br />参数:<br />n status – Bit-mask(0-21)位掩码,22个可用的渲染状态通过OR包含在一起<br /><br />int sceGuGetAllStatus(void)<br />查询所有的22个渲染状态<br />返回:22个渲染状态是否可用<br /><br />void sceGuEnable(int state)<br />使指定渲染状态可用<br />当前可用的渲染状态<br />GU_ALPHA_TEST<br />GU_DEPTH_TEST<br />GU_SCISSOR_TEST<br />GU_BLEND<br />GU_CULL_FACE<br />GU_DITHER<br />GU_CLIP_PLANES<br />GU_TEXTURE_2D<br />GU_LIGHTING<br />GU_LIGHT0<br />GU_LIGHT1<br />GU_LIGHT2<br />GU_LIGHT3<br />GU_COLOR_LOGIC_OP<br />参数:<br />n state – 指定可用的渲染状态<br /><br />void sceGuDisable(int state)<br />使指定的渲染状态失效<br />参数<br />n state – 指定失效的渲染状态<br /><br /><br />void sceGuLight(int light,<br />int type,<br />int components,<br />const ScePspFVector3* position)<br />设置光源参数<br />光源类型:<br />GU_DIRECTIONAL – 方向光<br />GU_POINTLIGHT – 点光源<br />GU_SPOTLIGHT – 聚光灯<br />可用的光源分量:<br />GU_AMBIENT_AND_DIFFUSE – 环境光和漫反射<br />GU_DIFFUSE_AND_SPECULAR – 漫反射和境面高光<br />GU_UNKNOWN_LIGHT_COMPONEN – 未知<br />参数:<br />n light – 光源索引<br />n type – 光源类型<br />n components – 光源分量<br />n position – 光源位子<br /><br /><br /><br />void sceGuLightAtt(int light,<br />float atten0,<br />float atten1,<br />float atten2)<br />设置光源的衰减<br />参数:<br />n light – 光源索引<br />n atten0 –衰减常数<br />n atten1 – 线性衰减<br />n atten2 – 二次衰减<br />void sceGuLightColor(int light,<br />int components,<br />unsigned int color)<br />设置光源颜色<br />可用的光源分量<br />· GU_AMBIENT<br />· GU_DIFFUSE<br />· GU_SPECULAR<br />· GU_AMBIENT_AND_DIFFUSE<br />· GU_DIFFUSE_AND_SPECULAR<br />参数:<br />n light – 光源索引<br />n component – 光源分量<br />n color 光源颜色<br /><br />void sceGuLightMode (int mode)<br />光源的模式<br />模式:<br />· GU_SINGLE_COLOR<br />· GU_SEPARATE_APECULAR_COLOR<br /><br />Separate specular colors are used to interpolate the specular component independently, so that it can be added to the fragment after the texture color<br />参数<br />n mode – 那个模式将被使用<br /><br />void sceGuLightSpot (int light, const ScePspFVector3 *direction, float exponent, float cutoff)<br />聚光灯参数<br />参数:<br />n light – 光源参数<br />n direction – 光源方向<br />n exponent – 聚光灯指数<br />n cutoff – 发射光锥角度,以弧度为单位<br /><br /><br />void sceGuClear(int flags)<br />清理当前的drawbuffer<br />可用的标志(可以OR来使用)<br />· GU_COLOR_BUFFER_BIT – 清理颜色缓存<br />· GU_STENCIL_BUFFER_BIT – 清理模版缓存<br />· GU_DEPTH_BUFFER_BIT – 清理深度缓存<br />参数:<br />n flags – 要清理的缓冲<br /><br />void sceGuClearColor(unsigned int color)<br />设置用于清空DrawBuffer的颜色<br />参数<br />n color – 用于清空buffer的颜色<br /><br /><br />void sceGuClearDepth(unsigned int depth)<br />设置用于清空z - Buffer的值<br />参数<br />n depth - 用于清空buffer的值 0x0 – 0xffff<br /><br />void sceGuClearStencil(unsigned int stencil)<br />设置用于清空stencil - Buffer的值<br />参数<br />n stencil – 用于清空buffer的值,0 – 255<br /><br /><br />void sceGuPixelMask(unsigned int mask)<br />设置象素的可写的掩码<br />参数:<br />n mask – 象素那些位可写的位掩码<br /><br />void sceGuColor(unsigned int color)<br />设置当前顶点的颜色<br />参数<br />n color – 颜色<br /><br />void sceGuColorFunc(int func,<br />unsigned int color,<br />unsigned int mask)<br />颜色测试函数.<br />颜色测试只有在GU_COLOR_TEST被使用时有效<br />颜色测试函数<br />· GU_NEVER<br />· GU_ALWAYS<br />· GU_EQUAL<br />· GU_NOTEQUAL<br />例子:蓝色通道不为0的象素都不被使用<br />sceGuColorFunc(GU_EQUAL,0,0XFF0000);<br />参数:<br />· func –颜色测试函数<br />· color – 测试用颜色<br />· mask – 位掩码,决定那些颜色的那些位参与测试,源和目标都有效<br /><br />void sceGuColorMaterial(int components)<br />设置材质的分量<br />可以将以下的标志通过或组合在一起<br />· GU_AMBIENT<br />· GU_DIFFUSE<br />· GU_SPECULAR<br />参数:<br />n Components – 传入的材质分量<br /><br />void sceGuAlphaFunc(int func,<br />int value,<br />int mask)<br />设置alpha测试的参数<br />alpha测试参数如下:<br />· GU_NEVER<br />· GU_ALWAYS<br />· GU_EQUAL<br />· GU_NOTEQUAL<br />· GU_LESS<br />· GU_LEQUAL<br />· GU_GREATER<br />· GU_GEQUAL<br />参数:<br />n func – alpha测试函数<br />n value – 参与测试的alpha值<br />n mask – 位掩码,那些位参与测试,对源和目标都有效<br /><br /><br />void sceGuAmbient(unsigned int color)<br />设置环境光<br />参数:<br />n color – 环境光颜色<br /><br /><br />void sceGuAmbientColor(unsigned int color)<br /><br /><br />void sceGuBlendFunc(int op,<br />int src,<br />int dest,<br />unsigned int srcfix,<br />unsigned int destfix)<br />设置混合模式<br />混合操作变量:<br />· Cs – 源颜色<br />· Cd – 目标颜色<br />· Bs – 源混合函数<br />· Bd – 目标混合函数<br />混合操作:<br />· GU_ADD – (Cs * Bs) + (Cd * Bd)<br />· GU_SUBTRACT – (Cs*Bs) – (Cd * Bd)<br />· GU_REVERSE_SUBTRACT – (Cd*Bd) – (Cs*Bs)<br />· GU_MIN – Cs<Cd?Cs:Cd<br />· GU_MAX – Cs<Cd?Cd:Cs<br />· GU_ABS - |Cs - Cd|<br />混合超作函数:<br />· GU_SRC_COLOR<br />· GU_ONE_MINUS_SRC_COLOR<br />· GU_SRC_ALPHA<br />· GU_ONE_MINUS_SRC_ALPHA<br />· GU_DST_ALPHA<br />· GU_ONE_MINUS_DST_ALPHA<br />· GU_DST_COLOR<br />· GU_ONE_MINUS_DST_COLOR<br />· GU_FIX<br />参数:<br />n op – 合成操作<br />n src – 源混合函数<br />n dest –目标混合函数<br />n srcfix – 源固定值,GU_FIX<br />n destfix – 目标固定值GU_FIX<br /><br /><br />void sceGuMaterial (int mode, int color)<br /><br /><br />void sceGuModelColor (unsigned int emissive, unsigned int ambient, unsigned int diffuse, unsigned int specular)<br /><br />void sceGuStencilFunc(int func,int ref,int mask)<br />模版测试函数,和参考值<br />测试函数:<br />· GU_NEVER<br />· GU_ALWAYS<br />· GU_EQUAL<br />· GU_NOTEQUAL<br />· GU_LESS<br />· GU_LEQUAL<br />· GU_GREATER<br />· GU_GEQUAL<br />参数:<br />n func – 测试函数<br />n ref – 参考值<br />n mask – 位掩码,对测试前和测试后的值有效<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />void sceGuStencilOp(int fail,<br />int zfail,<br />int zpass)<br />设置模版操作<br /><br /><br /><br /><br />· GU_KEEP – 保持当前值<br />· GU_ZERO – 对模版buffer清零<br />· GU_REPLACE – 用参考值替换当前值,参看sceStencilFunc<br />· GU_INCR – 对当前的值进行加一操作<br />· GU_DECT – 对当前的值进行减一操作<br />· GU_INVERT – 对当前的值进行位反操作<br />参数<br />n fail – 模版测试失败的动作<br />n zfail – 模版测试成功,但是深度测试失败的操作<br />n zpass – 模版和深度测试成功后的操作<br /><br /><br />void sceGuSpecular(float power)<br />设置材质的境面高光亮度<br />参数<br />n power – 亮度<br /><br /><br />void sceGuFrontFace(int order)<br />设置对三角形的背面消隐方式,只有GU_CULL_FACE被启用才有效<br />选择方式:<br />· GU_CW – 顺时针方式将会被使用, 逆时针被精选掉<br />· GU_CCW – 逆时针方式将会被使用, 顺时针方式被精选掉<br />参数<br />n order – 使用的顺序<br /><br />void sceGuLogicalOp(int op)<br />设置颜色的逻辑操作,只有当GU_COLOR_LOGIC_OP启用才有效<br />操作:<br />· GU_CLEAR<br />· GU_AND<br />· GU_AND_REVERSE<br />· GU_COPY<br />· GU_AND_INVERTED<br />· GU_NOOP<br />· GU_XOR<br />· GU_OR<br />· GU_EQUIV<br />· GU_INVERTED<br />· GU_OR_REVERSE<br />· GU_COPY_INVERTED<br />· GU_OR_INVERTED<br />· GU_NAND<br />· GU_SET<br />参数:<br />n op – 执行的操作<br /><br />void sceGuSetDither(const ScePsplMatrix4* matrix)<br />Set ordered pixel dither matrix.<br />This dither matrix is only applied if GU_DITHER is enabled.<br />Parameters:<br />n matrix - Dither matrix<br /><br /><br />void sceGuShadeModel(int mode)<br />作色方式<br />· GU_FLAT – 平面作色<br />· GU_SMOOTH – gouraud作色<br />参数<br />n mode – 将被使用的作色方式<br /><br />void sceGuCopyImage(int psm,<br />int sx,<br />int sy,<br />int width,<br />int height,<br />int srcw,<br />void* src,<br />int dx,<br />int dy,<br />int destw,<br />void dest)<br />使用GE来copy图象<br />注意:数据必须16字节对其<br />例子:从RAM拷贝一个全屏32位图象到VRAM<br />sceGuCopyImage(GU_PSM_8888,0,0,480,272,512,pixels,0,0,512,(void*)(((unsigned int)framebuffer)+0x4000000));<br />参数:<br />n psm – 象素格式<br />n sx – 源x坐标<br />n sy – 源y坐标<br />n width – 图象宽<br />n height – 图象高<br />n srcw – 源buffer宽<br />n src – 源buffer<br />n dx – 目标x坐标<br />n dy – 目标y坐标<br />n destw – 源buffer宽<br />n dest – 目标buffer<br /><br /><br />void sceGuTexEnvColor(unsigned int color)<br />设置纹理的环境色,具体参见sceGuTexFunc<br />参数<br />n color – 颜色常数(0x00bbggrr)<br /><br />void sceGuTexFilter(int min,<br />int mag)<br />设置纹理的filter<br />filter:<br />· GU_NEAREST<br />· GU_LINEAR<br />· GU_NEAREST_MIPMAP_NEAREST<br />· GU_LINEAR_MIPMAP_NEAREST<br />· GU_NEAREST_MIPMAP_LINAR<br />· GU_LINEAR_MIPMAP_LINEAR<br />参数<br />n min – 缩小filter<br />n mag – 放大filter<br /><br /><br />void sceGuTexFlush(void)<br />清空纹理页面缓存<br />Do this if you have copied/rendered into an area currently in the texture-cache<br /><br />void sceGuTexImage(int mipmap,<br />int width,<br />int height,<br />int tbw,<br />const void* tbp)<br />设置当前的纹理<br />纹理可能在住存中,不过这样会有很大的速度损失.调配纹理以取得最大速度<br />注意:数据要16字节对其<br />参数<br />n mipmap – mipmap 层<br />n width – 纹理宽(2的指数倍)<br />n height – 纹理高(2的指数倍)<br />n tbw – 纹理buffer宽(16字节对齐)<br />n tbp – 纹理buffer<br /><br /><br />void sceGuTexLevelMode(unsigned int a0,<br />float f12)<br /><br />void sceGuTexMapMode(int mode,<br />unsigned int a1,<br />unsigned int a2)<br />设置纹理的映射方式<br />· GU_TEXTURE_COORDS<br />· GU_TEXTURE_MATRIX<br />· GU_ENVIRONMENT_MAP<br />参数:<br />n mode – 纹理映射方式<br />n a1 –未知<br />n a2 - 未知<br /><br />void sceGuTexMode(int tpsm,<br />int maxmips,<br />int a2,<br />int swizzle)<br />设置纹理参数<br />纹理格式:<br />· GU_PSM_5650 – 高彩,16位<br />· GU_PSM_5551 – 高彩,16位<br />· GU_PSM_4444 -高彩,16位<br />· GU_PSM_8888 –真彩,32位<br />· GU_PSM_T4 – 调色板 4位(两个象素一字节)<br />· GU_PSM_T8 – 调色把 8位<br />参数<br />n tpsm – 纹理格式<br />n maxmips – mipmap的数量(0-8)<br />n a2 – 未知,设置0<br />n swizzle – GU_TRUE 优化纹理读取<br /><br /><br /><br /><br />void sceGuTexOffset(float u,<br />float v)<br />设置纹理偏移<br />注意:只用于3d T&L管线,GU_TRANSFORM_2D不受影响<br />参数<br />n u – U轴的偏移<br />n v – V轴的偏移<br /><br /><br />void sceGuTexProjMapMode(int mode)<br />设置纹理投影方式<br />· GU_POSITION<br />· GU_UV<br />· GU_NORMALIZED_NORMAL<br />· GU_NORMAL<br />参数<br />n mode – 投影方式<br /><br /><br />void sceGuTexScale(float u,<br />float v)<br />设置纹理的缩放<br />注意:只用于3d T&L管线,GU_TRANSFORM_2D不受影响<br />参数<br />n u – U轴的缩放<br />n v –V轴的缩放<br /><br /><br />void sceGuTexSlope(float slope)<br /><br /><br />void sceGuTexSync()<br />同步渲染管线,等到sceGuCopyImage完成<br /><br /><br />void sceGuTexWrap(int u,<br />int v)<br />设置纹理的包装方式<br />· GU_REPEAT – 重复<br />· GU_CLAMP – 边界色填充<br />参数<br /><br />n u – U轴包装方式<br />n v – V轴包装方式<br /><br />void sceGuClutLoad(int num_blocks,<br />const void* cbp)<br />载入CLUT(color lookup table颜色查找表)<br />注意:数据16字节对齐<br />参数<br />n num_blocks – 块的数量,每块8个元素<br />n cbp – 调色板(16字节对齐)<br />void sceGuClutMode(unsigned int cpsm,<br />unsigned int a1,<br />unsigned int a2,<br />unsigned int a3)<br />设置当前的CLUT方式<br />调色板的格式:<br />· GU_PSM_5650<br />· GU_PSM_5551<br />· GU_PSM_4444<br />· GU_PSM_8888<br />参数<br />n cpsm – 调色板的格式<br />n a1 – 未知,置0<br />n a2 – 未知,置0<br />n a3 – 未知,置0<br /><br /><br /><br /><br />void sceGuOffset(unsigned int x,<br />unsigned int y)<br />设置虚轴的偏移<br />PSP有一个虚轴空间为4096*4096,用以控制渲染的呈现<br />例子:设置渲染的中心<br />sceGuOffset(2048 – (480/2),2048 – (480/2))<br />参数<br />n x – 偏移(0-4098)<br />n y - 偏移(0-4098)<br /><br /><br />void sceGuScissor(int x,int y,int w,int h)<br />在当前的视口中设置裁减区域<br />只有当GU_SCISSOR_TEST启用后有效<br />参数<br />n x – 裁减区域X轴起始坐标<br />n y – 裁减区域Y轴起始坐标<br />n w – 裁减区域宽<br />n h - 裁减区域高<br /><br />void sceGuViewport(int cx,<br />int cy,<br />int width,<br />int height)<br />设置视口<br />例子:设置一个大小为480*272的视口<br />sceGuViewport(2048,2048,480,272);<br />参数:<br />n cx –视口中心的X坐标<br />n cy – 视口中心的Y坐标<br />n width – 视口宽<br />n height – 视口高<br /><br /><br />void sceGuDrawBezier(int vtype,<br />int ucount,<br />int vcount,<br />const void* indices,<br />const void* vertices)<br />Bezier页面<br />参数:<br />n vtype – 顶点类型,具体参见sceGuDrawArray<br />n ucount – 行上的顶点数量<br />n vcount - 列上的顶点数量<br />n indices – 顶点索引buffer<br />n vertices – 顶点buffer<br /><br />void sceGuPatchDivide (unsigned int a0, unsigned int a1)<br />void sceGuPatchFrontFace (unsigned int a0)<br />void sceGuPatchPrim (unsigned int a0)<br />void sceGuDrawSpline (int vtype, int ucount, int vcount, int uedge, int vedge, const void *indices, const void *vertices)<br /><br /><br />void sceGuSetMatrix(int type,<br />const ScePspFMatrix4* matrix)<br />设置转换矩阵<br />· GU_PROJECTION – View -> Project matrix<br />· GU_VIEW – World ->View matrix<br />· GU_MODEL – Model ->World matrix<br />· GU_TEXTURE – Texture matrix<br />参数<br />n type – 设置矩阵类型<br />n matrix – 矩阵<br /><br /><br /><br />void sceGuBoneMatrix(unsigned int index,<br />const ScePspFMatrix4* matrix)<br />骨骼矩阵<br />具体参见sceGuDrawArray中的顶点定义<br />参数:<br />n index – 将被设置的矩阵索引<br />n matrix – 载入的矩阵<br /><br />void sceGuMorphWeight(int index,<br />float weight)<br />设置举证的权重<br />具体参见sceGuDrawArray中的顶点定义<br />参数<br />n index – 将被设置的权重索引<br />n weight – 设置权重<br /><br />void sceGuDrawArrayN (int primitive_type, int vertex_type, int count, int a3, const void *indices, const void *vertices)<br />void guSwapBuffersBehaviour(int behaviour)<br />void guSwapBuffersCallback(GuSwapBuffersCallback callback)</p>
</div>
</div>


            
            <div class="row">
                <nav aria-label="Page navigation example">
                    <ul class="pagination justify-content-center">
                    <!--<li class="page-item disabled">
                        <a class="page-link">Previous</a>
                    </li>
                    <li class="page-item"><a class="page-link" href="#">1</a></li>
                    <li class="page-item"><a class="page-link" href="#">2</a></li>
                    <li class="page-item"><a class="page-link" href="#">3</a></li>
                    <li class="page-item">
                        <a class="page-link" href="#">Next</a>
                    </li>
                        -->
                        <li class="page-item active">
<a class="page-link" href="post16941_1.html">1</a>
</li>


                    </ul>
                </nav>
            </div>
        </div>


        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    </body>
</html>

