
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>lua 面向对象程序设计</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    </head>

    <body style="margin-top:1.618%">
        <div class="container">
            <div class="row">
                <div class="jumbotron">
                    <h1 class="display-5">lua 面向对象程序设计</h1>
                </div>
                <br />
                <nav class="nav">
                    <a class="nav-link active" aria-current="page" href="index_16.html">返回</a>
                </nav>
            </div>

            <hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2010-01-18 20:42:40</p>
</div>
<div class="col-10">
<p>Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：<br />Account = {balance = 0}<br />function Account.withdraw (v)<br />    Account.balance = Account.balance - v<br />end<br />这个定义创建了一个新的函数，并且保存在Account对象的withdraw域内，下面我们可以这样调用：<br />Account.withdraw(100.00)<br />这种函数就是我们所谓的方法，然而，在一个函数内部使用全局变量名Account是一个不好的习惯。首先，这个函数只能在这个特殊的对象（译者：指 Account）中使用；第二，即使对这个特殊的对象而言，这个函数也只有在对象被存储在特殊的变量（译者：指Account）中才可以使用。如果我们改变了这个对象的名字，函数withdraw将不能工作：<br />a = Account; Account = nil<br />a.withdraw(100.00)  -- ERROR!<br />这种行为违背了前面的对象应该有独立的生命周期的原则。<br />一个灵活的方法是：定义方法的时候带上一个额外的参数，来表示方法作用的对象。这个参数经常为self或者this：<br />function Account.withdraw (self, v)<br />    self.balance = self.balance - v<br />end<br />现在，当我们调用这个方法的时候不需要指定他操作的对象了：<br />a1 = Account; Account = nil<br />...<br />a1.withdraw(a1, 100.00)    -- OK<br />使用self参数定义函数后，我们可以将这个函数用于多个对象上：<br />a2 = {balance=0, withdraw = Account.withdraw}<br />...<br />a2.withdraw(a2, 260.00)<br />self参数的使用是很多面向对象语言的要点。大多数OO语言将这种机制隐藏起来，这样程序员不必声明这个参数（虽然仍然可以在方法内使用这个参数）。Lua也提供了通过使用冒号操作符来隐藏这个参数的声明。我们可以重写上面的代码：<br />function Account:withdraw (v)<br />    self.balance = self.balance - v<br />end<br />调用方法如下：<br />a:withdraw(100.00)<br />冒号的效果相当于在函数定义和函数调用的时候，增加一个额外的隐藏参数。这种方式只是提供了一种方便的语法，实际上并没有什么新的内容。我们可以使用dot语法定义函数而用冒号语法调用函数，反之亦然，只要我们正确的处理好额外的参数：<br />Account = {<br />    balance=0,<br />    withdraw = function (self, v)<br />      self.balance = self.balance - v<br />    end<br />}<br /><br />function Account:deposit (v)<br />    self.balance = self.balance + v<br />end<br /><br />Account.deposit(Account, 200.00)<br />Account:withdraw(100.00)<br />现在我们的对象拥有一个标示符，一个状态和操作这个状态的方法。但他们依然缺少一个class系统，继承和隐藏。先解决第一个问题：我们如何才能创建拥有相似行为的多个对象呢？明确地说，我们怎样才能创建多个accounts？（译者：针对上面的对象Account而言）<br />16.1 类<br />一些面向对象的语言中提供了类的概念，作为创建对象的模板。在这些语言里，对象是类的实例。Lua不存在类的概念，每个对象定义他自己的行为并拥有自己的形状（shape）。然而，依据基于原型（prototype）的语言比如Self和NewtonScript，在Lua中仿效类的概念并不难。在这些语言中，对象没有类。相反，每个对象都有一个prototype（原型），当调用不属于对象的某些操作时，会最先会到prototype中查找这些操作。在这类语言中实现类（class）的机制，我们创建一个对象，作为其它对象的原型即可（原型对象为类，其它对象为类的instance）。类与 prototype的工作机制相同，都是定义了特定对象的行为。<br />在Lua中，使用前面章节我们介绍过的继承的思想，很容易实现prototypes.更明确的来说，如果我们有两个对象a和b，我们想让b作为a的prototype只需要：<br />setmetatable(a, {__index = b})<br />这样，对象a调用任何不存在的成员都会到对象b中查找。术语上，可以将b看作类，a看作对象。回到前面银行账号的例子上。为了使得新创建的对象拥有和 Account相似的行为，我们使用__index metamethod，使新的对象继承Account。注意一个小的优化：我们不需要创建一个额外的表作为account对象的metatable；我们可以用Account表本身作为metatable：<br />function Account:new (o)<br />    o = o or {}  -- create object if user does not provide one<br />    setmetatable(o, self)<br />    self.__index = self<br />    return o<br />end<br />（当我们调用Account:new时，self等于Account；因此我们可以直接使用Account取代self。然而，使用self在我们下一节介绍类继承时更合适）。有了这段代码之后，当我们创建一个新的账号并且掉用一个方法的时候，有什么发生呢？<br />a = Account:new{balance = 0}<br />a:deposit(100.00)<br />当我们创建这个新的账号a的时候，a将Account作为他的metatable（调用Account:new时，self即Account）。当我们调用 a:deposit(100.00)，我们实际上调用的是a.deposit(a,100.00)（冒号仅仅是语法上的便利）。然而，Lua在表a中找不到deposit，因此他回到metatable的__index对应的表中查找，情况大致如下：<br />getmetatable(a).__index.deposit(a, 100.00)<br />a的metatable是Account，Account.__index也是Account（因为new函数中self.__index = self）。所以我们可以重写上面的代码为：<br />Account.deposit(a, 100.00)<br />也就是说，Lua传递a作为self参数调用原始的deposit函数。所以，新的账号对象从Account继承了deposit方法。使用同样的机制，可以从Account继承所有的域。继承机制不仅对方法有效，对表中所有的域都有效。所以，一个类不仅提供方法，也提供了他的实例的成员的默认值。记住：在我们第一个Account定义中，我们提供了成员balance默认值为0，所以，如果我们创建一个新的账号而没有提供balance的初始值，他将继承默认值：<br />b = Account:new()<br />print(b.balance)    --> 0<br />当我们调用b的deposit方法时，实际等价于：<br />b.balance = b.balance + v<br />（因为self就是b）。表达式b.balance等于0并且初始的存款（b.balance）被赋予b.balance。下一次我们访问这个值的时候，不会在涉及到index metamethod，因为b已经存在他自己的balance域。<br />16.2 继承<br />通常面向对象语言中，继承使得类可以访问其他类的方法，这在Lua中也很容易现实：<br />假定我们有一个基类Account：<br />Account = {balance = 0}<br /><br />function Account:new (o)<br />    o = o or {}<br />    setmetatable(o, self)<br />    self.__index = self<br />    return o<br />end<br /><br />function Account:deposit (v)<br />    self.balance = self.balance + v<br />end<br /><br />function Account:withdraw (v)<br />    if v > self.balance then error"insufficient funds" end<br />    self.balance = self.balance - v<br />end<br />我们打算从基类派生出一个子类SpecialAccount，这个子类允许客户取款超过它的存款余额限制，我们从一个空类开始，从基类继承所有操作：<br />SpecialAccount = Account:new()<br />到现在为止，SpecialAccount仅仅是Account的一个实例。现在奇妙的事情发生了：<br />s = SpecialAccount:new{limit=1000.00}<br />SpecialAccount 从Account继承了new方法，当new执行的时候，self参数指向SpecialAccount。所以，s的metatable是 SpecialAccount，__index 也是SpecialAccount。这样，s继承了SpecialAccount，后者继承了Account。当我们执行：<br />s:deposit(100.00)<br />Lua在s中找不到deposit域，他会到SpecialAccount中查找，在SpecialAccount中找不到，会到Account中查找。使得SpecialAccount特殊之处在于，它可以重定义从父类中继承来的方法：<br />function SpecialAccount:withdraw (v)<br />    if v - self.balance >= self:getLimit() then<br />      error"insufficient funds"<br />    end<br />    self.balance = self.balance - v<br />end<br /><br />function SpecialAccount:getLimit ()<br />    return self.limit or 0<br />end<br />现在，当我们调用方法s:withdraw(200.00)，Lua不会到Account中查找，因为它第一次救在SpecialAccount中发现了新的withdraw方法，由于s.limit等于1000.00（记住我们创建s的时候初始化了这个值）程序执行了取款操作，s的balance变成了负值。<br />在Lua中面向对象有趣的一个方面是你不需要创建一个新类去指定一个新的行为。如果仅仅一个对象需要特殊的行为，你可以直接在对象中实现，例如，如果账号s表示一些特殊的客户：取款限制是他的存款的10%，你只需要修改这个单独的账号：<br />function s:getLimit ()<br />    return self.balance * 0.10<br />end<br />这样声明之后，调用s:withdraw(200.00)将运行SpecialAccount的withdraw方法，但是当方法调用self:getLimit时，最后的定义被触发。<br />16.3 多重继承<br />由于Lua中的对象不是元生(primitive)的，所以在Lua中有很多方法可以实现面向对象的程序设计。我们前面所见到的使用index metamethod的方法可能是简洁、性能、灵活各方面综合最好的。然而，针对一些特殊情况也有更适合的实现方式。下面我们在Lua中多重继承的实现。<br />实现的关键在于：将函数用作__index。记住，当一个表的metatable存在一个__index函数时，如果Lua调用一个原始表中不存在的函数，Lua将调用这个__index指定的函数。这样可以用__index实现在多个父类中查找子类不存在的域。<br />多重继承意味着一个类拥有多个父类，所以，我们不能用创建一个类的方法去创建子类。取而代之的是，我们定义一个特殊的函数createClass来完成这个功能，将被创建的新类的父类作为这个函数的参数。这个函数创建一个表来表示新类，并且将它的metatable设定为一个可以实现多继承的__index metamethod。尽管是多重继承，每一个实例依然属于一个在其中能找得到它需要的方法的单独的类。所以，这种类和父类之间的关系与传统的类与实例的关系是有区别的。特别是，一个类不能同时是其实例的metatable又是自己的metatable。在下面的实现中，我们将一个类作为他的实例的 metatable，创建另一个表作为类的metatable：<br />-- look up for `k' in list of tables 'plist'<br />local function search (k, plist)<br />    for i=1, table.getn(plist) do<br />      local v = plist[k]    -- try 'i'-th superclass<br />      if v then return v end<br />    end<br />end<br /><br />function createClass (...)<br />    local c = {}      -- new class<br /><br />    -- class will search for each method in the list of its<br />    -- parents (`arg' is the list of parents)<br />    setmetatable(c, {__index = function (t, k)<br /><br />    return search(k, arg)<br />end})<br /><br />-- prepare `c' to be the metatable of its instances<br />c.__index = c<br /><br />-- define a new constructor for this new class<br />function c:new (o)<br />    o = o or {}<br />    setmetatable(o, c)<br />    return o<br />end<br /><br />-- return new class<br />    return c<br />end<br />让我们用一个小例子阐明一下createClass的使用，假定我们前面的类Account和另一个类Named，Named只有两个方法setname and getname：<br />Named = {}<br />function Named:getname ()<br />    return self.name<br />end<br /><br />function Named:setname (n)<br />    self.name = n<br />end<br />为了创建一个继承于这两个类的新类，我们调用createClass：<br />NamedAccount = createClass(Account, Named)<br />为了创建和使用实例，我们像通常一样：<br />account = NamedAccount:new{name = "Paul"}<br />print(account:getname())    --> Paul<br />现在我们看看上面最后一句发生了什么，Lua在account中找不到getname，因此他查找account的metatable的__index，即 NamedAccount。但是，NamedAccount也没有getname，因此Lua查找NamedAccount 的metatable的__index，因为这个域包含一个函数，Lua调用这个函数并首先到Account中查找getname，没有找到，然后到 Named中查找，找到并返回最终的结果。当然，由于搜索的复杂性，多重继承的效率比起单继承要低。一个简单的改善性能的方法是将继承方法拷贝到子类。使用这种技术，index方法如下：<br />...<br /><br />setmetatable(c, {__index = function (t, k)<br />    local v = search(k, arg)<br />    t[k] = v      -- save for next access<br />    return v<br />end})<br /><br />...<br />应用这个技巧，访问继承的方法和访问局部方法一样快（特别是第一次访问）。缺点是系统运行之后，很难改变方法的定义，因为这种改变不能影响继承链的下端。<br />16.4 私有性（privacy）<br />很多人认为私有性是面向对象语言的应有的一部分。每个对象的状态应该是这个对象自己的事情。在一些面向对象的语言中，比如C++和Java你可以控制对象成员变量或者成员方法是否私有。其他一些语言比如Smalltalk中，所有的成员变量都是私有，所有的成员方法都是公有的。第一个面向对象语言 Simula不提供任何保护成员机制。<br />如前面我们所看到的Lua中的主要对象设计不提供私有性访问机制。部分原因因为这是我们使用通用数据结构 tables来表示对象的结果。但是这也反映了后来的Lua的设计思想。Lua没有打算被用来进行大型的程序设计，相反，Lua目标定于小型到中型的程序设计，通常是作为大型系统的一部分。典型的，被一个或者很少几个程序员开发，甚至被非程序员使用。所以，Lua避免太冗余和太多的人为限制。如果你不想访问一个对象内的一些东西就不要访问（If you do not want to access something inside an object, just do not do it.）。<br />然而，Lua的另一个目标是灵活性，提供程序员元机制（meta- mechanisms），通过他你可以实现很多不同的机制。虽然Lua中基本的面向对象设计并不提供私有性访问的机制，我们可以用不同的方式来实现他。虽然这种实现并不常用，但知道他也是有益的，不仅因为它展示了Lua的一些有趣的角落，也因为它可能是某些问题的很好地解决方案。设计的基本思想是，每个对象用两个表来表示：一个描述状态；另一个描述操作（或者叫接口）。对象本身通过第二个表来访问，也就是说，通过接口来访问对象。为了避免未授权的访问，表示状态的表中不涉及到操作；表示操作的表也不涉及到状态，取而代之的是，状态被保存在方法的闭包内。例如，用这种设计表述我们的银行账号，我们使用下面的函数工厂创建新的对象：<br />function newAccount (initialBalance)<br />    local self = {balance = initialBalance}<br />    local withdraw = function (v)<br />      self.balance = self.balance - v<br />    end<br /><br />    local deposit = function (v)<br />      self.balance = self.balance + v<br />    end<br /><br />    local getBalance = function () return self.balance end<br /><br />    return {<br />      withdraw = withdraw,<br />      deposit = deposit,<br />      getBalance = getBalance<br />    }<br />end<br />首先，函数创建一个表用来描述对象的内部状态，并保存在局部变量self内。然后，函数为对象的每一个方法创建闭包（也就是说，嵌套的函数实例）。最后，函数创建并返回外部对象，外部对象中将局部方法名指向最终要实现的方法。这儿的关键点在于：这些方法没有使用额外的参数self，代替的是直接访问 self。因为没有这个额外的参数，我们不能使用冒号语法来访问这些对象。函数只能像其他函数一样调用：<br />acc1 = newAccount(100.00)<br />acc1.withdraw(40.00)<br />print(acc1.getBalance())    --> 60<br />这种设计实现了任何存储在self表中的部分都是私有的，newAccount返回之后，没有什么方法可以直接访问对象，我们只能通过newAccount 中定义的函数来访问他。虽然我们的例子中仅仅将一个变量放到私有表中，但是我们可以将对象的任何的部分放到私有表中。我们也可以定义私有方法，他们看起来象公有的，但我们并不将其放到接口中。例如，我们的账号可以给某些用户取款享有额外的10%的存款上限，但是我们不想用户直接访问这种计算的详细信息，我们实现如下：<br />function newAccount (initialBalance)<br />    local self = {<br />      balance = initialBalance,<br />      LIM = 10000.00,<br />    }<br /><br />    local extra = function ()<br />      if self.balance > self.LIM then<br />          return self.balance*0.10<br />      else<br />          return 0<br />      end<br />    end<br /><br />    local getBalance = function ()<br />      return self.balance + self.extra()<br />    end<br /><br />    ...<br />这样，对于用户而言就没有办法直接访问extra函数了。<br />16.5 Single-Method的对象实现方法<br />前面的OO程序设计的方法有一种特殊情况：对象只有一个单一的方法。这种情况下，我们不需要创建一个接口表，取而代之的是，我们将这个单一的方法作为对象返回。这听起来有些不可思议，如果需要可以复习一下7.1节，那里我们介绍了如何构造迭代子函数来保存闭包的状态。其实，一个保存状态的迭代子函数就是一个 single-method对象。<br />关于single-method的对象一个有趣的情况是：当这个single-method实际是一个基于重要的参数而执行不同的任务的分派（dispatch）方法时。针对这种对象：<br />function newObject (value)<br />    return function (action, v)<br />      if action == "get" then return value<br />      elseif action == "set" then value = v<br />      else error("invalid action")<br />      end<br />    end<br />end<br />使用起来很简单：<br />d = newObject(0)<br />print(d("get"))      --> 0<br />d("set", 10)<br />print(d("get"))      --> 10<br />这种非传统的对象实现是非常有效的，语法d("set",10)虽然很罕见，但也只不过比传统的d:set(10)长两个字符而已。每一个对象是用一个单独的闭包，代价比起表来小的多。这种方式没有继承但有私有性：访问对象状态的唯一方式是通过它的内部方法。<br />Tcl/Tk 的窗口部件（widgets）使用了相似的方法，在Tk中一个窗口部件的名字表示一个在窗口部件上执行各种可能操作的函数（a widget command）。</p>
</div>
</div>


            
            <div class="row">
                <nav aria-label="Page navigation example">
                    <ul class="pagination justify-content-center">
                    <!--<li class="page-item disabled">
                        <a class="page-link">Previous</a>
                    </li>
                    <li class="page-item"><a class="page-link" href="#">1</a></li>
                    <li class="page-item"><a class="page-link" href="#">2</a></li>
                    <li class="page-item"><a class="page-link" href="#">3</a></li>
                    <li class="page-item">
                        <a class="page-link" href="#">Next</a>
                    </li>
                        -->
                        <li class="page-item active">
<a class="page-link" href="post15953_1.html">1</a>
</li>


                    </ul>
                </nav>
            </div>
        </div>


        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    </body>
</html>

