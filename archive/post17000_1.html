
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>PSP开发指南第5课</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    </head>

    <body style="margin-top:1.618%">
        <div class="container">
            <div class="row">
                <div class="jumbotron">
                    <h1 class="display-5">PSP开发指南第5课</h1>
                </div>
                <br />
                <nav class="nav">
                    <a class="nav-link active" aria-current="page" href="index_18.html">返回</a>
                </nav>
            </div>

            <hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2008-06-07 16:16:26</p>
</div>
<div class="col-10">
<p>摘自：[url]http://blog.donews.com/pspdoc[/url]<br /><br />在学会架设开发环境，编写第一个程序，领略一些编程技巧，并且涉猎列一些经典程序之后，接下来我们开始第五课，你不要想这里有什么会让你感到惊讶的，这只是通过学习一些高级的概念来增强我们的编程技巧。<br /><br /> <br /><br />高级，这个只是个人看法，我们其实只是增强我们的C基础.以便于将来在真正高级的应用程序上编写程序。学过这节课后，你应该掌握如何"超频"到 psp真正的333MHz的速度。能够将文字讯息显示到屏幕上（图片文本，不是我们之前用的debug文本），并且了解在psp上的颜色工作是如何进行的。<br /><br /> <br /><br />我们所要创建的程序是背景转换，因为我们需要允许用户在背景上选择颜色，所以我们要转换它，并且将转换的颜色元素显示在屏幕上。<br /><br />首先是关于一些背景知识，这里存在一个关于psp 的“超频”的普遍的误解。因为本来观念的原因，人们很容易联想到"超频"会伤害和损坏硬件。说"超频"psp对硬件是危险的，简直是无稽之谈。这种情况并不只是在psp上出现。实际上，psp从出厂后就已经降频。为什么sony这么做，，有几个说法。一种是sony因为它会非常快的消耗掉电池（对我们来说到是无关紧要的，运转UMD比从记忆棒上读取存储需要用掉更大的能量，所以我们在电池寿命的方面已经有一个很大的优势）。另一种说法是sony希望开发者去编写更新的代码。而更多人认同第三种说法（跟我本人的观点也基本相符）是他们希望将来可以通过允许开发者在一些要点上可以用到全速，来推进游戏程序编程的发展。总之，psp正常的运行速度是222MHz,如果你需要更大的力量来运行你的程序，"超频"是一个选择。而我们这里所要编辑的程序，将用不到我上面所说得那些，但是我想这是一个很好地时机来介绍这个概念。<br /><br />现在，让我们开始我们的程序，你需要下载另外一个压缩文件，你点击”here”可以获得链接。释放这个压缩文件，你需要在文件夹里面创建一个main.c文件。<br /><br />#include <pspkernel.h><br />#include <pspdisplay.h><br />#include <pspctrl.h><br />#include <stdio.h><br />#include <psppower.h><br /><br />#include "graphics.h"<br /><br />假设你已经看过前面几课，这里就没有什么东西是你看不明白的。包括唯一对你有点陌生的"psppower.h"。这个文件包含了我们可以用来快速改变psp时钟的的函数。<br /><br />列出一些常见的代码：<br /><br />PSP_MODULE_INFO("Background Changer", 0, 1, 1);<br /><br />#define RGB(r, g, b) ((r)|((g)<<8)|((b)<<16))<br /><br />记得在第二课我们只是一笔带过这些代码而没有对他们究竟是做什么用加以解释。现在是时候让你们知道了，第一个参数是你的程序标识符，基本上是你程序的名字。第二个参数允许你传入属性。因为你的大多数程序，你将只是用到一个0，但是如果你编辑一个内核的应用模式，你将需要把它转换成"0x1000"，第三个参数是掌管转换（翻译），第四个是辅助转换（翻译）。他们是用来给你的程序的转换数据的。<br /><br /> <br /><br />标准的回叫:<br />/* Exit callback */<br />int exit_callback(int arg1, int arg2, void *common) {<br />          sceKernelExitGame();<br />          return 0;<br />}<br /><br />/* Callback thread */<br />int CallbackThread(SceSize args, void *argp) {<br />          int cbid;<br /><br />          cbid = sceKernelCreateCallback("Exit Callback", exit_callback, NULL);<br />          sceKernelRegisterExitCallback(cbid);<br /><br />          sceKernelSleepThreadCB();<br /><br />          return 0;<br />}<br /><br />/* Sets up the callback thread and returns its thread id */<br />int SetupCallbacks(void) {<br />          int thid = 0;<br /><br />          thid = sceKernelCreateThread("update_thread", CallbackThread, 0x11, 0xFA0, 0, 0);<br />          if(thid >= 0) {<br />                    sceKernelStartThread(thid, 0, 0);<br />          }<br /><br />          return thid;<br />}<br /><br />现在我们把它的骨骼架设起来了，我们应该让我们的程序有血有肉，应用main()主函数。<br /><br />int main(void) {<br />          scePowerSetClockFrequency(333, 333, 166);<br /><br />这个数据行是用来设置时钟的频率（丛函数名字就可以很显然地看出来），你可能很奇怪为什么有三个参数，我想问，是否这三个中只有一个是处理器呢？答案是错误的，psp 实际上有三个处理器。第一个是CPU(中央处理器),你得几乎所有的程序都需要它来处理。第二个参数是媒体播放器，第三个我该怎么说呢，你可以在你的处理器上运行MIPS 汇编代码。媒体播放器的速度是333 MHz，第三个参数控制图形中心，这就是人们常说得"GPU","GPU"的运行速度在166 MHz，默认的速度是"222, 222, 111."（如果你自己没有改变它的话）。<br />接下来，我们把它显示在屏幕上，跟我们上一课所作的一样：<br /><br />          SetupCallbacks();<br />          initGraphics();<br /><br />因为我们的输入需要要被接受，回忆一下第三课所讲的，我们需要定义一个SceCtrlData类型的变量，我们定义它为："pad."<br /><br />          SceCtrlData pad;<br /><br />我们再设立两个变量和一个数组：<br /><br />          int i;<br />          int selComponent = 0;<br />          char filler[10];<br /><br />整数"i,"将被运用到我们接下来的一个循环，字符数组我们把它用作一个字符串来输出一些这个程序之后信息。"selComponent"是我们用作纪录用户是使用哪一种颜色。<br /><br />下面我们要声明并且初始化的三个变量是用来存储我们的背景信息的。一种颜色是有三种成分构成的：红、绿、蓝。用32 位来表示，每一种颜色在的最大值是255。对每一种颜色，零是黑色，255是白色。1~255之间的就是复合色。有时候，你会看到用16位值来描绘颜色。 16位是基于16来计算的系统。他是从0运行到F（F就是16）。所以，在32位的系统下，FF=255（即16*16，减1的原因是因为你是从零开始计算的）所以，白色就是"FFFFFF"（255红，255兰，255绿）。总之，我们用这三种变量来存储背景颜色信息：<br /><br />          int bgR = 0;<br />          int bgG = 0;<br />          int bgB = 0;<br /><br />目前我们的背景是黑色，尽管这样，它也是存储了信息以便于我们可以熟练的运用它。我们实际上并不需要设置背景的颜色为黑色，那需要我们改变这些变量的值。<br /><br />因为我们需要用"graphics.h"文件而不是用pspDebugScreenPrintf来显示信息,我们需要告诉我们的程序我们要用哪些颜色。<br /><br />          Color highlightColor = RGB(200, 200, 200);<br />          Color dimmedColor = RGB(100, 100, 100);<br />          Color shadowColorH = RGB(55, 55, 55 );<br />          Color shadowColorD = RGB(55, 55, 55 );<br /><br />首先，我要解释这些数据行在做什么，他们在运用RGB宏，这个我们在第四课已经做以解释—他们把颜色成分转换为单色。"Color" 数据类型在"graphics.c"的包含文件中有定义，你也可以通过u32（一个32位整型）在一些程序中来控制一种颜色。<br /><br />这节课用到四个变量是因为我们希望加亮这些用户通常转换的颜色成分。所以我们有两个主颜色，一种颜色是为了高亮文字，另一种是为了暗淡的文字。同样，我们有一个动态背景（意味着背景是变幻的）我们将用到一个影子，它可以帮助我们的文档从背景里面突出出来，我试过很多颜色，随意使用这些颜色从而找到你最喜欢的一种。<br /><br />继续我们的游戏循环：<br /><br />          while(1) {<br />                    sceCtrlReadBufferPositive(&pad, 1);<br /><br />一个标准的无限while循环和手柄控制信息读入的函数<br /><br />现在我们掌握了手柄控制信息读入的函数，我们所要做的就是用上下键选择颜色。我们用左右键来调节那些颜色。<br /><br />                    if(pad.Buttons & PSP_CTRL_UP) {<br />                              if(selComponent > 0) {<br />                                        selComponent--;<br />                              }<br />                              for(i=0; i<10; i++) {<br />                                        sceDisplayWaitVblankStart();<br />                              }<br />                    } else if(pad.Buttons & PSP_CTRL_DOWN) {<br />                              if(selComponent < 2) {<br />                                        selComponent++;<br />                              }<br />                              for(i=0; i<10; i++) {<br />                                        sceDisplayWaitVblankStart();<br />                              }<br />                    }<br /><br />代码块的应用是前半部分是这样得，如果点击上键，他就会减少变量（因为我们想要从上边开始运行，0是最上边的颜色，1是中间颜色，2是末端颜色）如果按下向下键，他就会增加变量。当某个按钮按下的时候For循环的作用是用来停顿程序一会，这样就大大简化了用户的操作。<br /><br />下面的代码块是控制左右键的：<br /><br />  if(pad.Buttons & PSP_CTRL_RIGHT) {<br />                              switch(selComponent) {<br />                                        case 0:<br />                                                  bgR++;<br />                                                  break;<br />                                        case 1:<br />                                                  bgG++;<br />                                                  break;<br />                                        case 2:<br />                                                  bgB++;<br />                                                  break;<br />                                        default:<br />                                                  //SHOULD NEVER EXECUTE<br />                                                  break;<br />                              }<br />                    } else if(pad.Buttons & PSP_CTRL_LEFT) {<br />                              switch(selComponent) {<br />                                        case 0:<br />                                                  bgR--;<br />                                                  break;<br />                                        case 1:<br />                                                  bgG--;<br />                                                  break;<br />                                        case 2:<br />                                                  bgB--;<br />                                                  break;<br />                                        default:<br />                                                  //SHOULD NEVER EXECUTE<br />                                                  break;<br />                              }<br />                    }<br /><br />当你看到这些代码，你可能会自问: switch是什么意思？这个问题非常简单，这个比较像if/else。它用到一个变量，"switch(你的变量)”,举例说明，在我们的程序中，"selComponent"变量被限定为：0、1、2，<br /><br />如果"selComponent"等于0，我们的变量"bgR"将增加1，如果它等于1，"bgG"也增加1，如果它等于2，"bgB"也增加1，这时break语句就会退出转换结构。但是如果他找不到匹配的数值，那么程序将会运行默认的数值。<br /><br />这样，我们就有了允许我们修改颜色的代码，通过改变变量来改变颜色，下一步所要做的是在屏幕上显示的程序。我们的用户界面(UI)由文本组成，它可以告诉用户，界面的颜色成分和背景。<br /><br />我们说过，颜色的值是0-255，因为我们需要确认当用户运用它的时候取值不能超过这个范围，所以我们要运用一连串的if/else语句来限定取值范围。<br /><br />if(bgR < 0) {<br />                              bgR = 0;<br />                    } else if(bgR > 255) {<br />                              bgR = 255;<br />                    }<br />                    if(bgG < 0) {<br />                              bgG = 0;<br />                    } else if(bgG > 255) {<br />                              bgG = 255;<br />                    }<br />                    if(bgB < 0) {<br />                              bgB = 0;<br />                    } else if(bgB > 255) {<br />                              bgB = 255;<br />                    }<br /><br />这是一个漂亮的自我说明，如果颜色值超过这个范围，我们把它设置成范围的最大和最小值。<br /><br />现在根据我们的变量来填充我们的背景颜色。<br /><br />fillScreenRect(RGB(bgR, bgG, bgB), 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);<br /><br />"fillScreenRect()"是被"graphics.c."定义的一个函数。它是构成了矩形屏幕的特定颜色的一部分，他有五个参数，第一个是矩形的颜色，第二个是矩形的x点，第三个是矩形的y点，第四个是矩形的宽度。第五是矩形的高度。<br /><br />我们在背景上写文本需要我们键入：<br /><br />                    sprintf(filler, " RED: %i", bgR);<br />                    if(selComponent == 0) {<br />                              printTextScreen(11, 10, filler, shadowColorH);<br />                              printTextScreen(10, 10, filler, highlightColor);<br />                    } else {<br />                              printTextScreen(11, 10, filler, shadowColorD);<br />                              printTextScreen(10, 10, filler, dimmedColor);<br />                    }<br /><br />我们在第四课学过"sprintf ()"函数，那时我们对"printf()"在字符串中的作用做以解析，这次，我们用到一个变量，我们需要同时显示颜色（红色）和值(bgR)跟第三课的方法相同，我们输入一个整数，(用"%i")，一旦颜色成分被选定，我们就应用来自"graphics.c"的"printTextScreen()"函数来把我们的字符串打印到屏幕上。这个函数分为四个参数，第一个是x点，第二个是y点，第三个是字符串，第四个是颜色。用if/else语句的理由是因为我们想要在不同的被选定的颜色中显示文本。我们也要在文本的下面输入阴影。<br /><br />同样的方法应用在另外的两种颜色上：<br /><br />                    sprintf(filler, "GREEN: %i", bgG);<br />                    if(selComponent == 1) {<br />                              printTextScreen(11, 20, filler, shadowColorH);<br />                              printTextScreen(10, 20, filler, highlightColor);<br />                    } else {<br />                              printTextScreen(11, 20, filler, shadowColorD);<br />                              printTextScreen(10, 20, filler, dimmedColor);<br />                    }<br /><br />                    sprintf(filler, " BLUE: %i", bgB);<br />                    if(selComponent == 2) {<br />                              printTextScreen(11, 30, filler, shadowColorH);<br />                              printTextScreen(10, 30, filler, highlightColor);<br />                    } else {<br />                              printTextScreen(11, 30, filler, shadowColorD);<br />                              printTextScreen(10, 30, filler, dimmedColor);<br />                    }<br /><br />我们点击屏幕增加一小段的暂停来控制我们程序的速度（我们不希望它运行得太快）最后，修改我们的程序。<br /><br />                    flipScreen();<br /><br />                    for(i=0; i<1; i++) {<br />                              sceDisplayWaitVblankStart();<br />                    }<br />          }<br /><br />          return 0;<br />}<br /><br />现在，增加一个Makefile，为你的编译做准备。<br /><br />TARGET = BackgroundChanger<br />OBJS = main.o graphics.o framebuffer.o<br /><br />CFLAGS = -O2 -G0 -Wall<br />CXXFLAGS = $(CFLAGS) -fno-exceptions -fno-rtti<br />ASFLAGS = $(CFLAGS)<br /><br />LIBDIR =<br />LIBS = -lpspgu -lpsppower -lpng -lz -lm<br />LDFLAGS =<br /><br />EXTRA_TARGETS = EBOOT.PBP<br />PSP_EBOOT_TITLE = Background Changer<br /><br />PSPSDK=$(shell psp-config --pspsdk-path)<br />include $(PSPSDK)/lib/build.mak<br /><br />跟第四课的Makefile相同，除了名字和增加的 "-lpsppower," "-lpsppower,"是添加overclocking的库文件。现在你完成了它--背景转换器</p>
</div>
</div>


            
            <div class="row">
                <nav aria-label="Page navigation example">
                    <ul class="pagination justify-content-center">
                    <!--<li class="page-item disabled">
                        <a class="page-link">Previous</a>
                    </li>
                    <li class="page-item"><a class="page-link" href="#">1</a></li>
                    <li class="page-item"><a class="page-link" href="#">2</a></li>
                    <li class="page-item"><a class="page-link" href="#">3</a></li>
                    <li class="page-item">
                        <a class="page-link" href="#">Next</a>
                    </li>
                        -->
                        <li class="page-item active">
<a class="page-link" href="post17000_1.html">1</a>
</li>


                    </ul>
                </nav>
            </div>
        </div>


        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    </body>
</html>

