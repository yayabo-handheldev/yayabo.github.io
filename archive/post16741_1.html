
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>雷叔的白日梦 - 关于邪恶的HBlank</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    </head>

    <body style="margin-top:1.618%">
        <div class="container">
            <div class="row">
                <div class="jumbotron">
                    <h1 class="display-5">雷叔的白日梦 - 关于邪恶的HBlank</h1>
                </div>
                <br />
                <nav class="nav">
                    <a class="nav-link active" aria-current="page" href="index_17.html">返回</a>
                </nav>
            </div>

            <hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>雷精灵</b><br/>
2009-05-04 18:36:27</p>
</div>
<div class="col-10">
<p>官方游戏能做到的，我为什么做不到？——雷叔<br /><br />雷叔早就堕落了。从他开始拥有一台任天堂主机的时候，是的，从那时起，他就堕落了。<br />如同饥饿的人扑在刚出炉的面包上一样，如同吸血鬼扑在白净细嫩的处女脖颈上一样，如同丧尸扑在惊慌失措的R.P.D.警员身上一样，如同爆气的八神超必杀“八稚女”扑在随便谁身上一样，我记得很清楚，那个时候，雷叔就是那个样子扑在任天堂系列主机上的。<br /><br />当雷叔发现，GBA其实就是一个ARM的单片机的那一瞬间，我清楚地从他的那双眼睛中看到了饥饿和欲望的光芒。是的。就是饥饿和欲望。对未知领域——呃，精确地说，是对马上就要揭开那最后一块遮羞布但目前还是未知领域——的饥饿和欲望。<br /><br />……<br />好吧，随便你怎么想，反正我就是这么描述的……<br /><br />当雷叔发现，DS其实就是GBA穿了个马甲的那一瞬间，我又一次地从他那双眼睛中看到了饥饿和欲望的光芒。不过，这次的光芒中，还有一丝喜悦和……嗯，怎么描述呢？大概应该算是“庆幸”吧？——参杂在里面。<br /><br />——庆幸什么？我猜，大概是因为听说DS和GBA非常相似，于是就有种“轻车熟路”的感觉了吧……嗯，“违和感”。就像——<br />“哎呀，几位爷，快里面请！——刘叔，w叔，牛叔，六面叔，快下来陪几位爷~~~”<br />“少废话！我听说你们这里新来了个头牌叫掌家叔的……快叫她下来陪我家少爷！”<br />“哎呀！真不巧，掌家叔今天不见客。”<br />“连本少爷也不见？”<br />“哎呀！这不是雷少爷吗！”<br />“行了！别嚷嚷，老样子，让她下来陪本少爷！”<br /><br />当年2叔曾经写过一个DEMO，只使用1个图层，却能做出视差卷轴效果。当时雷叔对这种技术极为好奇。<br />2叔只说了一个词“HBlank”。<br />雷叔查找资料，终于在GBA中实现了这种效果。后来2叔把源代码给雷叔看，两人的实现方法几乎相同。<br />现在看来，这其实是一种很简单的技术。<br /><br />GBA/DS在扫描屏幕的时候，水平方向上并不是只扫描240/256个像素就跳到下一行去扫描，而是继续往后扫描，一直扫描227/355个像素点为止。多出来的那部分像素点，由于在屏幕上显示不出来，因此相当于空消耗时间而不会对屏幕内容有任何影响。如果在这块时间内对屏幕进行一些邪恶的操作，则不会影响已经扫描完的内容，只会有可能影响到将要扫描的内容。<br />比如说：屏幕按照某固定速度进行卷轴。如果在HBlank中更改卷轴速度，则扫描完的部分将不会受到影响，未扫描的部分自然以新的速度进行卷轴。于是此时屏幕就被撕裂开了。这就是只用一个BG实现视差卷轴的基本原理。<br /><br />雷叔：首先我需要注册一个HBlank的中断服务，每当HBlank发生的时候，程序进入中断服务。然后在中断服务中更改卷轴速度，或者卷轴偏移量就行了。<br />我：没错。GBA/DS中，卷轴寄存器中存放的是偏移量。<br />雷叔：很好。那就这么做吧。每个HBlank读取VCount值，获得当前扫描的是第几条扫描线，也就是y坐标。然后根据计算当前扫描线的卷轴偏移量，最后把结果赋给卷轴寄存器。<br />我：想法很正确，不过有一点需要注意。<br />雷叔：注意什么？<br />我：HBlank中断非常短。不要进行过于复杂的计算。否则有可能导致开始扫描下一扫描线的时候，甚至后一个中断到来的时候，当前中断服务还没响应完。<br />雷叔：那也很简单，预先把所有扫描线的卷轴偏移量都计算好，保存到某一数组中，HBlank的时候直接写值即可，无需计算了。<br />我：嗯。这样就很好了。当然，如果不是每个扫描线都需要改变卷轴速度的话，那么这个数组可以减小一些。<br />[code=c]<br />#include <nds.h><br />#include <fat.h><br />#include <stdio.h><br />#include <string.h><br />#include <unistd.h><br />#include "main.h"<br />#include "HsText.h"<br />#include "efs_lib.h"<br />#include "HsEncoding.h"<br /><br />//****************************资源********************************************//<br /><br />//****************************变量********************************************//<br />#define FRAMECOUNT_B	4<br />#define FRAMECOUNT_H	4<br /><br />const u16 textPalette[]={<br />		RGB5(0,	0,	0),	// Transparent<br />		RGB5(31,31,	31),// White<br />		RGB5(31,0,	0),	// Red<br />		RGB5(0,	31,	0),	// Green<br />		RGB5(0,	0,	31),// Blue<br />		RGB5(31,31,	0),	// Yellow<br />		RGB5(31,0,	31),// Purple<br />		RGB5(0,	31,	31),// Cyan<br />		RGB5(0,	0,	0),	// Black<br />};<br /><br />const static u8 gFrm[]={<br />	1,40,48,64,96,104,<br />};<br /><br />int x[6];<br /><br />FILE* tmpFile=NULL;<br />struct stat tmpStat;<br />void* tmpBuffer=NULL;<br />//****************************函数定义****************************************//<br />int main(void){<br />	int i=0;<br /><br />	irqSet(IRQ_HBLANK,HBlank);<br />	irqEnable(IRQ_HBLANK);<br /><br />	videoSetMode(MODE_0_2D);<br />	vramSetBankA(VRAM_A_MAIN_BG);<br />	dmaCopy(textPalette,BG_PALETTE,sizeof(textPalette));<br />	int textgroundID=Hs_TileTextInit(3,1,30,0);<br />	bgSetPriority(textgroundID,0);<br /><br />	Hs_ClearTileTextBG();<br />	Hs_TileTextOut("正在初始化文件系统…请稍候。",12,36,1);<br />	swiWaitForVBlank();<br />	if(!EFS_Init(EFS_AND_FAT|EFS_DEFAULT_DEVICE,NULL)){<br />		Hs_ClearTileTextBG();<br />		Hs_TileTextOut("初始化文件系统失败！",12,12,2);<br />		Hs_TileTextOut("ROM可能没有打正确的DLDI补丁！",12,24,5);<br />		Hs_TileTextOut("按任意键或点击屏幕关闭DS主机。",12,36,5);<br />		swiWaitForVBlank();<br />		while(TRUE){<br />			swiWaitForVBlank();<br />			scanKeys();<br />			if(keysDown())DSShutDown();<br />		}<br />	}<br /><br />	Hs_ClearTileTextBG();<br />	Hs_TileTextOut("正在初始化代码页…请稍候。",12,36,1);<br />	swiWaitForVBlank();<br />	if(!Hs_InitEncoding()){<br />		Hs_ClearTileTextBG();<br />		Hs_TileTextOut("初始化代码页失败！",12,12,2);<br />		Hs_TileTextOut("代码页数据文件可能已经丢失！",12,24,5);<br />		Hs_TileTextOut("按任意键或点击屏幕关闭DS主机。",12,36,5);<br />		swiWaitForVBlank();<br />		while(TRUE){<br />			swiWaitForVBlank();<br />			scanKeys();<br />			if(keysDown())DSShutDown();<br />		}<br />	}<br /><br />	Hs_ClearTileTextBG();<br />	Hs_TileTextOut("系统初始化成功！",12,36,3);<br />	swiWaitForVBlank();<br />	if(TRUE){<br />		char tmpString[256];<br />		memset(tmpString,0,sizeof(tmpString));<br />		strcpy(tmpString,"ROM路径为");<br />		char tmpString2[256];<br />		char tmpString3[256];<br />		memset(tmpString2,0,256);<br />		memset(tmpString3,0,256);<br />		UTF8_UTF16(efs_path,strlen(efs_path),tmpString2);<br />		UTF16_GBK(tmpString2,256,tmpString3);<br />		strcat(tmpString,tmpString3);<br />		Hs_TileTextOut_ACL(tmpString,12,12,7,256-12,256-6);<br />		swiWaitForVBlank();<br />		for(i=0;i<0x100;i++){<br />			swiWaitForVBlank();<br />			scanKeys();<br />			if(keysDown())break;<br />		}<br />	}<br /><br />	/**Main Screen*/<br />	videoSetMode(MODE_0_2D|DISPLAY_BG_EXT_PALETTE|DISPLAY_SPR_EXT_PALETTE);<br />	vramSetBankE(VRAM_E_LCD);<br /><br />	tmpFile=fopen("/Pokemon_Pal.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Pokemon_Pal_bin=tmpBuffer;<br />	int Pokemon_Pal_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	dmaCopy((void*)Pokemon_Pal_bin,(void*)(VRAM_E_EXT_PALETTE[1]),Pokemon_Pal_bin_size);<br />	vramSetBankE(VRAM_E_BG_EXT_PALETTE);<br />	vramSetBankA(VRAM_A_MAIN_BG);<br />	tmpFile=fopen("/Pokemon_Map.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Pokemon_Map_bin=tmpBuffer;<br />	int Pokemon_Map_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	tmpFile=fopen("/Pokemon_Tiles.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Pokemon_Tiles_bin=tmpBuffer;<br />	int Pokemon_Tiles_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	dmaCopy((void*)Pokemon_Map_bin,(void*)(SCREEN_BASE_BLOCK(31)),Pokemon_Map_bin_size);<br />	for(i=0;i<Pokemon_Map_bin_size>>1;i++)BG_MAP_RAM(31)[i]|=(1<<12);<br />	dmaCopy((void*)Pokemon_Tiles_bin,(void*)(CHAR_BASE_BLOCK(0)),Pokemon_Tiles_bin_size);<br /><br />	int backgroundID=bgInit(0,BgType_Text8bpp,BgSize_B8_512x256,31,0);<br />	dmaCopy(textPalette,BG_PALETTE,sizeof(textPalette));<br />	textgroundID=Hs_TileTextInit(3,1,30,0);<br /><br />	bgSetPriority(backgroundID,3);<br />	bgSetPriority(textgroundID,0);<br /><br />	/**Main Sprite*/<br />	oamInit(&oamMain,SpriteMapping_1D_128,true);<br />	vramSetBankF(VRAM_F_LCD);<br /><br />	tmpFile=fopen("/Bike_Pal.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Bike_Pal_bin=tmpBuffer;<br />	int Bike_Pal_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	tmpFile=fopen("/Haruka_Pal.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Haruka_Pal_bin=tmpBuffer;<br />	int Haruka_Pal_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	dmaCopy((void*)Bike_Pal_bin,(void*)VRAM_F_EXT_PALETTE,Bike_Pal_bin_size);<br />	dmaCopy((void*)Haruka_Pal_bin,(void*)(VRAM_F_EXT_PALETTE+1),Haruka_Pal_bin_size);<br />	vramSetBankF(VRAM_F_SPRITE_EXT_PALETTE);<br />	vramSetBankG(VRAM_G_MAIN_SPRITE);<br />	u16* gfxOffset_B=oamAllocateGfx(&oamMain,SpriteSize_64x32,SpriteColorFormat_256Color);<br />	u16* gfxOffset_H=oamAllocateGfx(&oamMain,SpriteSize_64x64,SpriteColorFormat_256Color);<br />	tmpFile=fopen("/Bike_Sprite.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Bike_Sprite_bin=tmpBuffer;<br />	int Bike_Sprite_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	tmpFile=fopen("/Haruka_Sprite.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Haruka_Sprite_bin=tmpBuffer;<br />	int Haruka_Sprite_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	dmaCopy((void*)Bike_Sprite_bin,(void*)gfxOffset_B,Bike_Sprite_bin_size/FRAMECOUNT_B);<br />	dmaCopy((void*)Haruka_Sprite_bin,(void*)gfxOffset_H,Haruka_Sprite_bin_size/FRAMECOUNT_H);<br />	oamSet(&oamMain,1,<br />			(SCREEN_WIDTH-64)>>1,SCREEN_HEIGHT-96,<br />			0,0,SpriteSize_64x32,SpriteColorFormat_256Color,gfxOffset_B,-1,<br />			false,false,false,false,false);<br />	oamSet(&oamMain,0,<br />			(SCREEN_WIDTH-64)>>1,SCREEN_HEIGHT-128+8,<br />			0,1,SpriteSize_64x64,SpriteColorFormat_256Color,gfxOffset_H,-1,<br />			false,false,false,false,false);<br /><br />	int Frame=0;<br />	int px=0;<br />	while(TRUE){<br />		swiWaitForVBlank();<br /><br />		scanKeys();<br />		if(keysHeld() & KEY_LEFT)px--;<br />		if(keysHeld() & KEY_RIGHT)px++;<br /><br />		// 视差卷轴特效<br />		Frame++;<br />		if(Frame%8==0)x[0]++;<br />		if(Frame%4==0)x[1]++;<br />		if(Frame%2==0)x[2]++;<br />		if(Frame%2==0)x[4]+=2;else x[4]++;<br />		if(Frame%8==0)x[5]+=4;else x[5]+=2;<br /><br />		dmaCopy(<br />				(void*)(Bike_Sprite_bin+Bike_Sprite_bin_size*((Frame>>3)%FRAMECOUNT_B)/FRAMECOUNT_B),<br />				(void*)gfxOffset_B,<br />				Bike_Sprite_bin_size/FRAMECOUNT_B);<br />		dmaCopy(<br />				(void*)(Haruka_Sprite_bin+Haruka_Sprite_bin_size*((Frame>>3)%FRAMECOUNT_H)/FRAMECOUNT_H),<br />				(void*)gfxOffset_H,<br />				Haruka_Sprite_bin_size/FRAMECOUNT_H);<br /><br />		oamSet(&oamMain,1,<br />				((SCREEN_WIDTH-64)>>1)+(px>>1),SCREEN_HEIGHT-96,<br />				0,0,SpriteSize_64x32,SpriteColorFormat_256Color,gfxOffset_B,-1,<br />				false,false,false,false,false);<br />		oamSet(&oamMain,0,<br />				((SCREEN_WIDTH-64)>>1)+(px>>1),SCREEN_HEIGHT-128+8,<br />				0,1,SpriteSize_64x64,SpriteColorFormat_256Color,gfxOffset_H,-1,<br />				false,false,false,false,false);<br /><br /><br />		oamUpdate(&oamMain);<br /><br />		if((keysHeld() & KEY_UP) || (keysDown() & KEY_X)){<br />			complexWinFX--;<br />			if(complexWinFX<0){<br />				gTransitionType=rand()&3;<br />				complexWinFX=64;<br />			}<br />		}<br />		if((keysHeld() & KEY_DOWN) || (keysDown() & KEY_B)){<br />			complexWinFX++;<br />			if(complexWinFX>64){<br />				gTransitionType=rand()&3;<br />				complexWinFX=0;<br />			}<br />		}<br />	}<br />	oamFreeGfx(&oamMain,gfxOffset_B);<br />	oamFreeGfx(&oamMain,gfxOffset_H);<br /><br />	free(Pokemon_Pal_bin);<br />	free(Pokemon_Map_bin);<br />	free(Pokemon_Tiles_bin);<br />	free(Bike_Pal_bin);<br />	free(Bike_Sprite_bin);<br />	free(Haruka_Pal_bin);<br />	free(Haruka_Sprite_bin);<br />	Pokemon_Pal_bin=NULL;<br />	Pokemon_Map_bin=NULL;<br />	Pokemon_Tiles_bin=NULL;<br />	Bike_Pal_bin=NULL;<br />	Bike_Sprite_bin=NULL;<br />	Haruka_Pal_bin=NULL;<br />	Haruka_Sprite_bin=NULL;<br /><br />	return 0;<br />}<br />//============================================================================//<br />static void HBlank(){<br />	vu16 Hframe=REG_VCOUNT&511;<br /><br />	int i=0;<br />	for(i=0;i<6;i++){<br />		if(Hframe==gFrm[i]){<br />//			bgScroll(backgroundID,-x[i],0);<br />//			bgUpdate();<br />			REG_BG0HOFS=-x[i];<br />			break;<br />		}<br />	}<br />}<br />//============================================================================//<br />void DSShutDown(){<br />	fifoSendValue32(FIFO_PM,PM_REQ_LED|(1<<6));<br />}<br />[/code]<br /><br />[attach]1126[/attach]<br /><br />我：很好！就是这种效果。<br />雷精灵：不过有一个BUG。我暂且不说，我估计下面还会遇到。<br /><br />GBA/DS中每渲染一次屏幕被称作“一帧”。但是由于HBlank的存在，导致“一帧”可以被拆开成若干“扫描线”。在HBlank中，只要进行了任何影响渲染的操作，都将导致复杂特效。比如：<br />如果在HBlank中改变窗口大小，那么，不同的扫描线就可以实现不同的窗口大小。假如窗口的大小是按照某种规律变化的，那么就可以做到复杂窗口特效。比如圆形窗口。<br />如果在HBlank中卷轴随着扫描线按照正弦波的规律改变，同时进行马赛克特效，则可以实现水波特效。当然，若要模拟一个比较像样的水波，可能还需要Fade特效。而且，算法也比较复杂。<br />如果在HBlank中每个扫描线更改不同调色盘，那么这就可以在普通的16色和256色BG中模拟出最高16*16*160=40960色BG（GBA下）/16*16*192=49152色BG（DS下）。嗯，可以说，这甚至已经比16bit的BG更加强大了。而且，也比16bit的BG更加节省内存。只需要付出一点点的代价，那就是代码的复杂程度和处理消耗的时间。由于DMA的速度非常地快，而且DMA会暂停CPU以保证DMA的过程，因此不会影响HBlank。唯独需要注意的是，在DS中双CPU的通信可能会有些意想不到的问题。<br />如果在HBlank中更改MAP和Tile，则可以彻底忽略GBA/DS中Tile模式下的Tile数量限制。换句话说，这就是无限Tile技术。<br /><br />雷叔：你知道我是为什么开始对HBlank有兴趣的吗？<br />我：不知道。<br />雷叔：其实这可以追溯到GBA时代。当时我玩《口袋妖怪》的时候，看到了一个技能“闪光术”。这种技能会在漆黑的洞窟中开出一个圆形的窗口。<br />我：哦！于是你就想：这是怎么实现的呢？<br />雷叔：没错。刚开始我认为是窗口特效。于是我就查找资料，寄存器的什么位是用来控制窗口形状的。<br />我：哈哈……结果你没找到，然后就认为是BG了。<br />雷叔：对。BG的话，非常容易实现。不过，我又注意到一件事情：那就是在使用“闪光术”的瞬间，圆形窗口逐渐变大，直到指定大小。<br />我：然后呢？<br />雷叔：当时我已经懂得了动态MAP和动态Tile技术，如果仔细做的话，用这两种技术都可以实现。于是在很长时间内，我都认为那是BG，不是窗口特效。<br />我：直到有一天，你在查看MAP的时候，发现不存在这个所谓的“圆形窗口层”。<br />雷叔：嗯。当时我相当惊异——真神奇啊！不是窗口，也不是BG，难道是精灵？结果OAM找了一圈也没找到所谓的“窗口精灵”。于是我就石化了……<br />我：那么，你又是什么时候才意识到它确实是窗口的呢？<br />雷叔：几分钟后。不晓得这到底是什么，于是我就开始开启/关闭VBA中的所有层和特效。然后我发现当关闭了窗口特效之后“闪光术”消失……<br />我：那你又是何时才知道原理的呢？<br />雷叔：最近。最近才悟出，“在HBlank中，只要进行了任何影响渲染的操作，都将导致复杂特效”。<br />我：那你又是何时才做出真正的圆形窗口特效的呢？<br />雷叔：在那之后，我就试着写了个DEMO。效果在DS模拟器上非常好。但是一上真机就出问题，当窗口的面积小于一定值的时候窗口无效。<br />我：是什么原因呢？<br />雷叔：当初我以为是乘方和开平方的缘故。因为HBlank中断不能有太复杂的运算，否则时间不够，于是我就拼命优化算法。最后连开平方都直接调用BIOS了。<br />我：然后？<br />雷叔：然后还不行。我感到很奇怪，于是又写了几个比较简单的复杂窗口特效比如百叶窗，结果发现也是在真机上有问题。我开始意识到这不是运算太复杂的缘故……事实上我到现在都不知道这到底是为什么，但是我却在w叔的指点下，成功地把这个问题回避过去了。<br /><br />[code=c]<br />#include <nds.h><br />#include <fat.h><br />#include <stdio.h><br />#include <string.h><br />#include <unistd.h><br />#include "main.h"<br />#include "HsText.h"<br />#include "efs_lib.h"<br />#include "HsEncoding.h"<br /><br />//****************************资源********************************************//<br /><br />//****************************变量********************************************//<br />#define FRAMECOUNT_B	4<br />#define FRAMECOUNT_H	4<br /><br />const u16 textPalette[]={<br />		RGB5(0,	0,	0),	// Transparent<br />		RGB5(31,31,	31),// White<br />		RGB5(31,0,	0),	// Red<br />		RGB5(0,	31,	0),	// Green<br />		RGB5(0,	0,	31),// Blue<br />		RGB5(31,31,	0),	// Yellow<br />		RGB5(31,0,	31),// Purple<br />		RGB5(0,	31,	31),// Cyan<br />		RGB5(0,	0,	0),	// Black<br />};<br /><br />const static u8 gFrm[]={<br />	1,40,48,64,96,104,<br />};<br /><br />int x[6];<br />int complexWinFX=64;<br />int gTransitionType=0;<br />u16 winX[192+1];<br /><br />FILE* tmpFile=NULL;<br />struct stat tmpStat;<br />void* tmpBuffer=NULL;<br />//****************************函数定义****************************************//<br />int main(void){<br />	int i=0;<br /><br />	irqSet(IRQ_HBLANK,HBlank);<br />	irqEnable(IRQ_HBLANK);<br /><br />	videoSetMode(MODE_0_2D);<br />	vramSetBankA(VRAM_A_MAIN_BG);<br />	dmaCopy(textPalette,BG_PALETTE,sizeof(textPalette));<br />	int textgroundID=Hs_TileTextInit(3,1,30,0);<br />	bgSetPriority(textgroundID,0);<br /><br />	Hs_ClearTileTextBG();<br />	Hs_TileTextOut("正在初始化文件系统…请稍候。",12,36,1);<br />	swiWaitForVBlank();<br />	if(!EFS_Init(EFS_AND_FAT|EFS_DEFAULT_DEVICE,NULL)){<br />		Hs_ClearTileTextBG();<br />		Hs_TileTextOut("初始化文件系统失败！",12,12,2);<br />		Hs_TileTextOut("ROM可能没有打正确的DLDI补丁！",12,24,5);<br />		Hs_TileTextOut("按任意键或点击屏幕关闭DS主机。",12,36,5);<br />		swiWaitForVBlank();<br />		while(TRUE){<br />			swiWaitForVBlank();<br />			scanKeys();<br />			if(keysDown())DSShutDown();<br />		}<br />	}<br /><br />	Hs_ClearTileTextBG();<br />	Hs_TileTextOut("正在初始化代码页…请稍候。",12,36,1);<br />	swiWaitForVBlank();<br />	if(!Hs_InitEncoding()){<br />		Hs_ClearTileTextBG();<br />		Hs_TileTextOut("初始化代码页失败！",12,12,2);<br />		Hs_TileTextOut("代码页数据文件可能已经丢失！",12,24,5);<br />		Hs_TileTextOut("按任意键或点击屏幕关闭DS主机。",12,36,5);<br />		swiWaitForVBlank();<br />		while(TRUE){<br />			swiWaitForVBlank();<br />			scanKeys();<br />			if(keysDown())DSShutDown();<br />		}<br />	}<br /><br />	Hs_ClearTileTextBG();<br />	Hs_TileTextOut("系统初始化成功！",12,36,3);<br />	swiWaitForVBlank();<br />	if(TRUE){<br />		char tmpString[256];<br />		memset(tmpString,0,sizeof(tmpString));<br />		strcpy(tmpString,"ROM路径为");<br />		char tmpString2[256];<br />		char tmpString3[256];<br />		memset(tmpString2,0,256);<br />		memset(tmpString3,0,256);<br />		UTF8_UTF16(efs_path,strlen(efs_path),tmpString2);<br />		UTF16_GBK(tmpString2,256,tmpString3);<br />		strcat(tmpString,tmpString3);<br />		Hs_TileTextOut_ACL(tmpString,12,12,7,256-12,256-6);<br />		swiWaitForVBlank();<br />		for(i=0;i<0x100;i++){<br />			swiWaitForVBlank();<br />			scanKeys();<br />			if(keysDown())break;<br />		}<br />	}<br /><br />	/**Main Screen*/<br />	videoSetMode(MODE_0_2D|DISPLAY_BG_EXT_PALETTE|DISPLAY_SPR_EXT_PALETTE);<br />	vramSetBankE(VRAM_E_LCD);<br />	tmpFile=fopen("/Pokemon_Pal.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Pokemon_Pal_bin=tmpBuffer;<br />	int Pokemon_Pal_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	dmaCopy((void*)Pokemon_Pal_bin,(void*)(VRAM_E_EXT_PALETTE[1]),Pokemon_Pal_bin_size);<br />	vramSetBankE(VRAM_E_BG_EXT_PALETTE);<br />	vramSetBankA(VRAM_A_MAIN_BG);<br />	tmpFile=fopen("/Pokemon_Map.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Pokemon_Map_bin=tmpBuffer;<br />	int Pokemon_Map_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	tmpFile=fopen("/Pokemon_Tiles.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Pokemon_Tiles_bin=tmpBuffer;<br />	int Pokemon_Tiles_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	dmaCopy((void*)Pokemon_Map_bin,(void*)(SCREEN_BASE_BLOCK(31)),Pokemon_Map_bin_size);<br />	for(i=0;i<Pokemon_Map_bin_size>>1;i++)BG_MAP_RAM(31)[i]|=(1<<12);<br />	dmaCopy((void*)Pokemon_Tiles_bin,(void*)(CHAR_BASE_BLOCK(0)),Pokemon_Tiles_bin_size);<br />	int backgroundID=bgInit(0,BgType_Text8bpp,BgSize_B8_512x256,31,0);<br /><br />	dmaCopy(textPalette,BG_PALETTE,sizeof(textPalette));<br />	textgroundID=Hs_TileTextInit(3,1,30,0);<br /><br />	bgSetPriority(backgroundID,3);<br />	bgSetPriority(textgroundID,0);<br /><br />	/**Main Sprite*/<br />	oamInit(&oamMain,SpriteMapping_1D_128,true);<br />	vramSetBankF(VRAM_F_LCD);<br />	tmpFile=fopen("/Bike_Pal.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Bike_Pal_bin=tmpBuffer;<br />	int Bike_Pal_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	tmpFile=fopen("/Haruka_Pal.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Haruka_Pal_bin=tmpBuffer;<br />	int Haruka_Pal_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	dmaCopy((void*)Bike_Pal_bin,(void*)VRAM_F_EXT_PALETTE,Bike_Pal_bin_size);<br />	dmaCopy((void*)Haruka_Pal_bin,(void*)(VRAM_F_EXT_PALETTE+1),Haruka_Pal_bin_size);<br />	vramSetBankF(VRAM_F_SPRITE_EXT_PALETTE);<br />	vramSetBankG(VRAM_G_MAIN_SPRITE);<br />	u16* gfxOffset_B=oamAllocateGfx(&oamMain,SpriteSize_64x32,SpriteColorFormat_256Color);<br />	u16* gfxOffset_H=oamAllocateGfx(&oamMain,SpriteSize_64x64,SpriteColorFormat_256Color);<br />	tmpFile=fopen("/Bike_Sprite.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Bike_Sprite_bin=tmpBuffer;<br />	int Bike_Sprite_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	tmpFile=fopen("/Haruka_Sprite.bin","rb");<br />	fstat(fileno(tmpFile),&tmpStat);<br />	tmpBuffer=calloc(1,tmpStat.st_size);<br />	fread(tmpBuffer,tmpStat.st_size,1,tmpFile);<br />	DC_FlushAll();<br />	fclose(tmpFile);<br />	void* Haruka_Sprite_bin=tmpBuffer;<br />	int Haruka_Sprite_bin_size=tmpStat.st_size;<br />	tmpFile=NULL;<br />	dmaCopy((void*)Bike_Sprite_bin,(void*)gfxOffset_B,Bike_Sprite_bin_size/FRAMECOUNT_B);<br />	dmaCopy((void*)Haruka_Sprite_bin,(void*)gfxOffset_H,Haruka_Sprite_bin_size/FRAMECOUNT_H);<br />	oamSet(&oamMain,1,<br />			(SCREEN_WIDTH-64)>>1,SCREEN_HEIGHT-96,<br />			0,0,SpriteSize_64x32,SpriteColorFormat_256Color,gfxOffset_B,-1,<br />			false,false,false,false,false);<br />	oamSet(&oamMain,0,<br />			(SCREEN_WIDTH-64)>>1,SCREEN_HEIGHT-128+8,<br />			0,1,SpriteSize_64x64,SpriteColorFormat_256Color,gfxOffset_H,-1,<br />			false,false,false,false,false);<br /><br />	// 开启Win0窗口<br />	REG_DISPCNT|=DISPLAY_WIN0_ON;<br />	// 窗外<br />	WIN_OUT=0;<br />	// 窗内<br />	WIN_IN=0xFFFF;<br /><br />	int Frame=0;<br />	int px=0;<br />	while(TRUE){<br />		swiWaitForVBlank();<br /><br />		WIN0_Y0=0;<br />		WIN0_Y1=192;<br />		// 计算窗口x坐标数组<br />		for(i=0;i<192;i++){<br />			switch(gTransitionType){<br />				case 0:{// 栅栏<br />					int tmp=complexWinFX<<2;<br />					tmp=tmp>255?0:255-tmp;<br />					winX[i]=(((i>>3)&1)?0:(tmp<<8))|(((i>>3)&1)?255-tmp:255);<br />				}break;<br />				case 1:{// 圆<br />					winX[i]=(((i&15)>=(complexWinFX>>2)?255:0)<<8)|255;<br />				}break;<br />				case 2:{// 百叶窗<br />					int tmp=(complexWinFX*5>>1)*(complexWinFX*5>>1)-(i-95)*(i-95);<br />					int x0;<br />					int x1;<br />					tmp=tmp<0?0:sqrt32(tmp);<br />					x0=127-tmp<0?0:127-tmp;<br />					x1=127+tmp>255?255:127+tmp;<br />					winX[i]=(x0<<8)|x1;<br />				}break;<br />				case 3:{// 随机杂线<br />					int tmp[192];<br />					if(complexWinFX==64){<br />						tmp[i]=rand()&255;<br />						winX[i]=255;<br />					}else if(complexWinFX==0){<br />						tmp[i]=rand()&255;<br />						winX[i]=(255<<8)|255;<br />					}else{<br />						winX[i]=((tmp[i]-(tmp[i]*complexWinFX>>6))<<8)|(tmp[i]+((255-tmp[i])*complexWinFX>>6));<br />					}<br />				}break;<br />			}<br />		}<br />		winX[192]=winX[0];<br /><br />		scanKeys();<br />		if(keysHeld() & KEY_LEFT)px--;<br />		if(keysHeld() & KEY_RIGHT)px++;<br /><br />		// 视差卷轴特效<br />		Frame++;<br />		if(Frame%8==0)x[0]++;<br />		if(Frame%4==0)x[1]++;<br />		if(Frame%2==0)x[2]++;<br />		if(Frame%2==0)x[4]+=2;else x[4]++;<br />		if(Frame%8==0)x[5]+=4;else x[5]+=2;<br /><br />		dmaCopy(<br />				(void*)(Bike_Sprite_bin+Bike_Sprite_bin_size*((Frame>>3)%FRAMECOUNT_B)/FRAMECOUNT_B),<br />				(void*)gfxOffset_B,<br />				Bike_Sprite_bin_size/FRAMECOUNT_B);<br />		dmaCopy(<br />				(void*)(Haruka_Sprite_bin+Haruka_Sprite_bin_size*((Frame>>3)%FRAMECOUNT_H)/FRAMECOUNT_H),<br />				(void*)gfxOffset_H,<br />				Haruka_Sprite_bin_size/FRAMECOUNT_H);<br /><br />		oamSet(&oamMain,1,<br />				((SCREEN_WIDTH-64)>>1)+(px>>1),SCREEN_HEIGHT-96,<br />				0,0,SpriteSize_64x32,SpriteColorFormat_256Color,gfxOffset_B,-1,<br />				false,false,false,false,false);<br />		oamSet(&oamMain,0,<br />				((SCREEN_WIDTH-64)>>1)+(px>>1),SCREEN_HEIGHT-128+8,<br />				0,1,SpriteSize_64x64,SpriteColorFormat_256Color,gfxOffset_H,-1,<br />				false,false,false,false,false);<br /><br />		oamUpdate(&oamMain);<br /><br />		if((keysHeld() & KEY_UP) || (keysDown() & KEY_X)){<br />			complexWinFX--;<br />			if(complexWinFX<0){<br />				gTransitionType=rand()&3;<br />				complexWinFX=64;<br />			}<br />		}<br />		if((keysHeld() & KEY_DOWN) || (keysDown() & KEY_B)){<br />			complexWinFX++;<br />			if(complexWinFX>64){<br />				gTransitionType=rand()&3;<br />				complexWinFX=0;<br />			}<br />		}<br />	}<br />	oamFreeGfx(&oamMain,gfxOffset_B);<br />	oamFreeGfx(&oamMain,gfxOffset_H);<br /><br />	free(Pokemon_Pal_bin);<br />	free(Pokemon_Map_bin);<br />	free(Pokemon_Tiles_bin);<br />	free(Bike_Pal_bin);<br />	free(Bike_Sprite_bin);<br />	free(Haruka_Pal_bin);<br />	free(Haruka_Sprite_bin);<br />	Pokemon_Pal_bin=NULL;<br />	Pokemon_Map_bin=NULL;<br />	Pokemon_Tiles_bin=NULL;<br />	Bike_Pal_bin=NULL;<br />	Bike_Sprite_bin=NULL;<br />	Haruka_Pal_bin=NULL;<br />	Haruka_Sprite_bin=NULL;<br /><br />	return 0;<br />}<br />//============================================================================//<br />static void HBlank(){<br />	vu16 Hframe=REG_VCOUNT&511;<br /><br />	int i=0;<br />	for(i=0;i<6;i++){<br />		if(Hframe==gFrm[i]){<br />//			bgScroll(backgroundID,-x[i],0);<br />//			bgUpdate();<br />			REG_BG0HOFS=-x[i];<br />			break;<br />		}<br />	}<br /><br />	// 复杂窗口特效<br />	*(vu16*)0x04000040=winX[Hframe+1];<br />}<br />//============================================================================//<br />void DSShutDown(){<br />	fifoSendValue32(FIFO_PM,PM_REQ_LED|(1<<6));<br />}<br />[/code]<br /><br />[attach]1127[/attach][attach]1128[/attach][attach]1129[/attach][attach]1130[/attach]<br /><br />w叔：你这种方法需要注册HBlank中断服务，然后在每个HBlank中传递数据。既然仅仅是向特定地址传递数据，为什么不使用HDMA呢？<br />雷叔：嗯……有道理！<br /><br />于是雷叔被w叔怂恿，开始研究HDMA了。但是很不幸，直到现在他还没有成功启动HDMA……<br /><br />什么是HDMA呢？HDMA是DMA的一种特定模式。在这种模式下，每当HBlank发生的时候，指定的DMA通道自动开始工作，把指定的数据传输到指定的地址中。在这个过程中完全无需人工干预。<br /><br />首先需要设置一个DMA通道。根据GBATEK，HBlank对时间要求比较严格，那么就用优先级最高的DMA0吧。然后需要设置DMA控制字。<br />[code=c]<br />DMA_CR(0)=0;<br />DMA_SRC(0)=(uint32)(&winX[1]);<br />DMA_DEST(0)=(uint32)(0x04000040);<br />DMA_CR(0)=DMA_COPY_HALFWORDS|1|DMA_REPEAT|DMA_START_HBL|DMA_DST_RESET;<br />[/code]<br />注意看，这里面的设置是非常精心的。<br />DS的硬件在设计DMA通道的时候为了省事提供了一些很有用的状态，我们得把它们合理利用上。在HDMA这种模式下，我们要求每次HBlank到来的时候（DMA_REPEAT|DMA_START_HBL），DMA通道要向指定目标地址（DMA_DEST(0)）传输指定源地址（DMA_SRC(0)）中指定数量（1）的指定长度（DMA_COPY_HALFWORDS）的数据。每次传输都是传输到指定寄存器所以目标地址固定不变（DMA_DST_FIX或者DMA_DST_RESET都行）。<br />这个时候出现一个有趣的问题：当某一次HBlank到来之后，HDMA开始运作，数据开始传输。当传输完成之后，DMA通道，尤其是“Enable”和“Busy”状态位，是什么状态呢？<br />事实证明，Enable状态位有效，证明当前DMA通道仍然在“占用状态”；而Busy状态位也有效，证明当前DMA通道还处于“忙”状态。直到所有的数据全都传输完，也就是那几百条扫描线全都扫描完，或者更通俗地说，当前帧已经渲染完的时候，Busy才变成无效。至于Enable状态位，只有我们手动关闭才会变成无效。<br />由此可见，我们必须在每次准备开始进行HDMA的时候，先将DMA通道关闭（DMA_CR(0)=0;），才能保证下面要进行的DMA传输是有效的；而且在设置好DMA并启动DMA通道之后，绝对不要等待DMA完成（while(DMA_CR(0)&DMA_BUSY);）。很简单，DMA什么时候才算完成？整整一帧全部渲染完成才算完成。<br /><br />把上面那个代码片断加到VBlank或者主循环的swiWaitForVBlank();之后，就可以将HBlank中断服务去掉了。<br /><br />我：我注意到一件有趣的事情。无论是否使用HBlank中断服务，你往寄存器里面传输的数据，总是当前VCount的值+1。<br />雷叔：没错。分析一下，当VCount=0的时候，或者说第0个HBlank到来的时候，第0条扫描线已经渲染完成了。所以这个时候进行操作，肯定是针对第1条扫描线了。因此自然就是数组的第1号元素。所以HBlank中断里面写成了*(vu16*)0x04000040=winX[Hframe+1];，HDMA里面写成了DMA_SRC(0)=(uint32)(&winX[1]);。同时，我在定义winX这个数组的时候，故意将其定义成192+1个元素这么大。……不过，哪怕定义成192个元素其实也无所谓，因为最后一条扫描线的HBlank到来的时候，整个屏幕已经渲染完成，紧接着就是VBlank发生了。那么这条扫描线也就无所谓再设置什么了。顺便一说，VBlank到来之后中HBlank就停止了，证明在这一帧中它的使命已经完成。<br />我：由此看来，第0条扫描线将永远不会被复杂特效所影响？<br />雷叔：正解。除非你的最后一条扫描线和第0条扫描线设置相同。这也就是为什么我令winX[192]=winX[0];的缘故。<br /><br />后记：<br />当雷叔攻克了HDMA之后，我又从他那双邪恶的眼睛中看到了令人不寒而栗的光芒。嗯……就像——<br />啊~~~太爽了！原来这种姿势是这么爽啊！<br />嗯~~~雷少爷啊，下次~~~我们玩点更有趣的花样~~~怎么样？<br />好啊！你果真是天生尤物……<br />嗯~~~讨厌啦~~~~<br /><br />……<br />我刚才什么都没说啊！你们什么都没看见啊！偷窥别人那啥是不道德的行为啊！<br /><br />[[i] 本帖最后由 雷精灵 于 2009-5-5 10:32 编辑 [/i]]</p>
</div>
</div>

<hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>掌叔</b><br/>
2009-05-04 20:01:39</p>
</div>
<div class="col-10">
<p>终于出现在雷叔的小说中了！不过这个身份惨了点~还好有刘叔，w叔，牛叔，六面叔陪我<br /><br />⊙﹏⊙b</p>
</div>
</div>

<hr class="my-4" />
<div class="row">
<div class="col-2">
<p><b>xxx111zz</b><br/>
2009-05-04 20:36:33</p>
</div>
<div class="col-10">
<p>网名:sunshine<br />性別:男<br />居住地:武汉<br />星座:处女座<br />在做的事:本科<br />希望：<br />希望能够深入研究NDS原理结构</p>
</div>
</div>


            
            <div class="row">
                <nav aria-label="Page navigation example">
                    <ul class="pagination justify-content-center">
                    <!--<li class="page-item disabled">
                        <a class="page-link">Previous</a>
                    </li>
                    <li class="page-item"><a class="page-link" href="#">1</a></li>
                    <li class="page-item"><a class="page-link" href="#">2</a></li>
                    <li class="page-item"><a class="page-link" href="#">3</a></li>
                    <li class="page-item">
                        <a class="page-link" href="#">Next</a>
                    </li>
                        -->
                        <li class="page-item active">
<a class="page-link" href="post16741_1.html">1</a>
</li>


                    </ul>
                </nav>
            </div>
        </div>


        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    </body>
</html>

